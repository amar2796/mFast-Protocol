// simple4.inl generated by mFAST from FAST Template. 
// Do not modify this file directly. Any modifications 
// will be lost the next time this file is generated.

inline
Nested_cref::Nested_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Nested_cref::Nested_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, Nested_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Nested_cref::Nested_cref(
  const mfast::message_cref& other)
  : base_type(other)
{
}

inline
Nested_cref::Nested_cref(
  const mfast::field_cref& other)
  : base_type(mfast::field_cref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Nested_cref::operator mfast::message_cref()
{
  return mfast::message_cref(this->storage(), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Nested_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<uint32_cref, copy_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_cref<uint32_cref, copy_operator_tag, properties_type< 0> > ((*this)[1]) );
}

inline
Nested_mref::Nested_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Nested_mref::Nested_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, Nested_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Nested_mref::Nested_mref(
  const mfast::message_mref& other)
  : base_type(other)
{
}

inline
Nested_mref::Nested_mref(
  const mfast::field_mref_base& other)
  : base_type(other.allocator(),
              mfast::field_mref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Nested_mref::operator mfast::message_mref()
{
  return mfast::message_mref(this->allocator(), const_cast<mfast::value_storage*>(this->storage()), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Nested_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<uint32_mref, copy_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_mref<uint32_mref, copy_operator_tag, properties_type< 0> > ((*this)[1]) );
}

inline
Nested::Nested(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
Nested::Nested(
  const Nested_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

#ifdef MFAST_JSON_H
Nested::Nested(
  const char* json_initializer,
  int json_object_tag_mask,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
  std::stringstream strm(json_initializer);
  mfast::json::decode(strm, this->mref(), json_object_tag_mask);
}

#endif
inline Nested::cref_type
Nested::ref() const
{
  return Nested::cref_type(my_storage_.of_group.content_, instruction());
}

inline Nested::cref_type
Nested::cref() const
{
  return Nested::cref_type(my_storage_.of_group.content_, instruction());
}

inline Nested::mref_type
Nested::ref()
{
  return Nested::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Nested::mref_type
Nested::mref()
{
  return Nested::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline mfast::uint32_cref
Nested_cref::get_field2() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_cref
Nested_cref::try_get_field2() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_mref
Nested_mref::set_field2() const
{
  return static_cast<mfast::uint32_mref>((*this)[0]);
}

inline mfast::uint32_cref
Nested_cref::get_field3() const
{
  return static_cast<mfast::uint32_cref>((*this)[1]);
}

inline mfast::uint32_cref
Nested_cref::try_get_field3() const
{
  return static_cast<mfast::uint32_cref>((*this)[1]);
}

inline mfast::uint32_mref
Nested_mref::set_field3() const
{
  return static_cast<mfast::uint32_mref>((*this)[1]);
}

inline
Unused0_cref::Unused0_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Unused0_cref::Unused0_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, Unused0_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Unused0_cref::Unused0_cref(
  const mfast::message_cref& other)
  : base_type(other)
{
}

inline
Unused0_cref::Unused0_cref(
  const mfast::field_cref& other)
  : base_type(mfast::field_cref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Unused0_cref::operator mfast::message_cref()
{
  return mfast::message_cref(this->storage(), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Unused0_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<uint32_cref, copy_operator_tag, properties_type< 0> > ((*this)[0]) );
}

inline
Unused0_mref::Unused0_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Unused0_mref::Unused0_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, Unused0_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Unused0_mref::Unused0_mref(
  const mfast::message_mref& other)
  : base_type(other)
{
}

inline
Unused0_mref::Unused0_mref(
  const mfast::field_mref_base& other)
  : base_type(other.allocator(),
              mfast::field_mref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Unused0_mref::operator mfast::message_mref()
{
  return mfast::message_mref(this->allocator(), const_cast<mfast::value_storage*>(this->storage()), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Unused0_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<uint32_mref, copy_operator_tag, properties_type< 0> > ((*this)[0]) );
}

inline
Unused0::Unused0(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
Unused0::Unused0(
  const Unused0_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

#ifdef MFAST_JSON_H
Unused0::Unused0(
  const char* json_initializer,
  int json_object_tag_mask,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
  std::stringstream strm(json_initializer);
  mfast::json::decode(strm, this->mref(), json_object_tag_mask);
}

#endif
inline Unused0::cref_type
Unused0::ref() const
{
  return Unused0::cref_type(my_storage_.of_group.content_, instruction());
}

inline Unused0::cref_type
Unused0::cref() const
{
  return Unused0::cref_type(my_storage_.of_group.content_, instruction());
}

inline Unused0::mref_type
Unused0::ref()
{
  return Unused0::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Unused0::mref_type
Unused0::mref()
{
  return Unused0::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline mfast::uint32_cref
Unused0_cref::get_field4() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_cref
Unused0_cref::try_get_field4() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_mref
Unused0_mref::set_field4() const
{
  return static_cast<mfast::uint32_mref>((*this)[0]);
}

inline
Unused1_cref::Unused1_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Unused1_cref::Unused1_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, Unused1_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Unused1_cref::Unused1_cref(
  const mfast::message_cref& other)
  : base_type(other)
{
}

inline
Unused1_cref::Unused1_cref(
  const mfast::field_cref& other)
  : base_type(mfast::field_cref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Unused1_cref::operator mfast::message_cref()
{
  return mfast::message_cref(this->storage(), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Unused1_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<uint32_cref, copy_operator_tag, properties_type< 0> > ((*this)[0]) );
}

inline
Unused1_mref::Unused1_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Unused1_mref::Unused1_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, Unused1_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Unused1_mref::Unused1_mref(
  const mfast::message_mref& other)
  : base_type(other)
{
}

inline
Unused1_mref::Unused1_mref(
  const mfast::field_mref_base& other)
  : base_type(other.allocator(),
              mfast::field_mref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Unused1_mref::operator mfast::message_mref()
{
  return mfast::message_mref(this->allocator(), const_cast<mfast::value_storage*>(this->storage()), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Unused1_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<uint32_mref, copy_operator_tag, properties_type< 0> > ((*this)[0]) );
}

inline
Unused1::Unused1(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
Unused1::Unused1(
  const Unused1_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

#ifdef MFAST_JSON_H
Unused1::Unused1(
  const char* json_initializer,
  int json_object_tag_mask,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
  std::stringstream strm(json_initializer);
  mfast::json::decode(strm, this->mref(), json_object_tag_mask);
}

#endif
inline Unused1::cref_type
Unused1::ref() const
{
  return Unused1::cref_type(my_storage_.of_group.content_, instruction());
}

inline Unused1::cref_type
Unused1::cref() const
{
  return Unused1::cref_type(my_storage_.of_group.content_, instruction());
}

inline Unused1::mref_type
Unused1::ref()
{
  return Unused1::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Unused1::mref_type
Unused1::mref()
{
  return Unused1::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline mfast::uint32_cref
Unused1_cref::get_field4() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_cref
Unused1_cref::try_get_field4() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_mref
Unused1_mref::set_field4() const
{
  return static_cast<mfast::uint32_mref>((*this)[0]);
}

inline
Test_cref::Test_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Test_cref::Test_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, Test_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Test_cref::Test_cref(
  const mfast::message_cref& other)
  : base_type(other)
{
}

inline
Test_cref::Test_cref(
  const mfast::field_cref& other)
  : base_type(mfast::field_cref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Test_cref::operator mfast::message_cref()
{
  return mfast::message_cref(this->storage(), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Test_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<uint32_cref, copy_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_cref<uint32_cref, copy_operator_tag, properties_type< 0> > ((*this)[1]) );
  visitor.visit(ext_cref<uint32_cref, copy_operator_tag, properties_type< 0> > ((*this)[2]) );
}

inline
Test_mref::Test_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Test_mref::Test_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, Test_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Test_mref::Test_mref(
  const mfast::message_mref& other)
  : base_type(other)
{
}

inline
Test_mref::Test_mref(
  const mfast::field_mref_base& other)
  : base_type(other.allocator(),
              mfast::field_mref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Test_mref::operator mfast::message_mref()
{
  return mfast::message_mref(this->allocator(), const_cast<mfast::value_storage*>(this->storage()), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Test_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<uint32_mref, copy_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_mref<uint32_mref, copy_operator_tag, properties_type< 0> > ((*this)[1]) );
  visitor.visit(ext_mref<uint32_mref, copy_operator_tag, properties_type< 0> > ((*this)[2]) );
}

inline
Test::Test(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
Test::Test(
  const Test_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

#ifdef MFAST_JSON_H
Test::Test(
  const char* json_initializer,
  int json_object_tag_mask,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
  std::stringstream strm(json_initializer);
  mfast::json::decode(strm, this->mref(), json_object_tag_mask);
}

#endif
inline Test::cref_type
Test::ref() const
{
  return Test::cref_type(my_storage_.of_group.content_, instruction());
}

inline Test::cref_type
Test::cref() const
{
  return Test::cref_type(my_storage_.of_group.content_, instruction());
}

inline Test::mref_type
Test::ref()
{
  return Test::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Test::mref_type
Test::mref()
{
  return Test::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline mfast::uint32_cref
Test_cref::get_field1() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_cref
Test_cref::try_get_field1() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_mref
Test_mref::set_field1() const
{
  return static_cast<mfast::uint32_mref>((*this)[0]);
}

inline mfast::uint32_cref
Test_cref::get_field2() const
{
  return static_cast<mfast::uint32_cref>((*this)[1]);
}

inline mfast::uint32_cref
Test_cref::try_get_field2() const
{
  return static_cast<mfast::uint32_cref>((*this)[1]);
}

inline mfast::uint32_mref
Test_mref::set_field2() const
{
  return static_cast<mfast::uint32_mref>((*this)[1]);
}

inline mfast::uint32_cref
Test_cref::get_field3() const
{
  return static_cast<mfast::uint32_cref>((*this)[2]);
}

inline mfast::uint32_cref
Test_cref::try_get_field3() const
{
  return static_cast<mfast::uint32_cref>((*this)[2]);
}

inline mfast::uint32_mref
Test_mref::set_field3() const
{
  return static_cast<mfast::uint32_mref>((*this)[2]);
}

