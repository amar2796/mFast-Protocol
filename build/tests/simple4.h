// simple4.h generated by mFAST from FAST Template. 
// Do not modify this file directly. Any modifications 
// will be lost the next time this file is generated.

#pragma once

#include <mfast.h>
namespace simple4
{

class Nested_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<Nested_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Nested_cref();
    template <typename T>
    Nested_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, Nested_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    Nested_cref(const mfast::message_cref& other);

    explicit Nested_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_cref get_field2() const;
    mfast::uint32_cref try_get_field2() const;
    mfast::uint32_cref get_field3() const;
    mfast::uint32_cref try_get_field3() const;

};


typedef mfast::make_aggregate_mref<Nested_cref> Nested_mref_base;
class Nested_mref
  : public Nested_mref_base
{
  typedef Nested_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<Nested_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Nested_mref();
    template <typename T>
    Nested_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, Nested_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    Nested_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit Nested_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_field2() const;
    mfast::uint32_mref set_field3() const;
};

class Nested
  : private mfast::value_storage_array<2>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 0
    };
    typedef mfast::template_instruction_ex<Nested_cref> instruction_type;

    typedef mfast::make_message_cref<Nested_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<Nested_mref, instruction_type> mref_type;
    Nested(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    Nested(
      const Nested_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit Nested(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    Nested(const Nested&);
    Nested& operator = (const Nested&);
};


class Unused0_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<Unused0_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Unused0_cref();
    template <typename T>
    Unused0_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, Unused0_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    Unused0_cref(const mfast::message_cref& other);

    explicit Unused0_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_cref get_field4() const;
    mfast::uint32_cref try_get_field4() const;

};


typedef mfast::make_aggregate_mref<Unused0_cref> Unused0_mref_base;
class Unused0_mref
  : public Unused0_mref_base
{
  typedef Unused0_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<Unused0_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Unused0_mref();
    template <typename T>
    Unused0_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, Unused0_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    Unused0_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit Unused0_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_field4() const;
};

class Unused0
  : private mfast::value_storage_array<1>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 0
    };
    typedef mfast::template_instruction_ex<Unused0_cref> instruction_type;

    typedef mfast::make_message_cref<Unused0_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<Unused0_mref, instruction_type> mref_type;
    Unused0(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    Unused0(
      const Unused0_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit Unused0(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    Unused0(const Unused0&);
    Unused0& operator = (const Unused0&);
};


class Unused1_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<Unused1_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Unused1_cref();
    template <typename T>
    Unused1_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, Unused1_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    Unused1_cref(const mfast::message_cref& other);

    explicit Unused1_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_cref get_field4() const;
    mfast::uint32_cref try_get_field4() const;

};


typedef mfast::make_aggregate_mref<Unused1_cref> Unused1_mref_base;
class Unused1_mref
  : public Unused1_mref_base
{
  typedef Unused1_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<Unused1_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Unused1_mref();
    template <typename T>
    Unused1_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, Unused1_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    Unused1_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit Unused1_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_field4() const;
};

class Unused1
  : private mfast::value_storage_array<1>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 1
    };
    typedef mfast::template_instruction_ex<Unused1_cref> instruction_type;

    typedef mfast::make_message_cref<Unused1_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<Unused1_mref, instruction_type> mref_type;
    Unused1(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    Unused1(
      const Unused1_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit Unused1(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    Unused1(const Unused1&);
    Unused1& operator = (const Unused1&);
};


class Test_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<Test_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Test_cref();
    template <typename T>
    Test_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, Test_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    Test_cref(const mfast::message_cref& other);

    explicit Test_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_cref get_field1() const;
    mfast::uint32_cref try_get_field1() const;
    mfast::uint32_cref get_field2() const;
    mfast::uint32_cref try_get_field2() const;
    mfast::uint32_cref get_field3() const;
    mfast::uint32_cref try_get_field3() const;

};


typedef mfast::make_aggregate_mref<Test_cref> Test_mref_base;
class Test_mref
  : public Test_mref_base
{
  typedef Test_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<Test_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Test_mref();
    template <typename T>
    Test_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, Test_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    Test_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit Test_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_field1() const;
    mfast::uint32_mref set_field2() const;
    mfast::uint32_mref set_field3() const;
};

class Test
  : private mfast::value_storage_array<3>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 2
    };
    typedef mfast::template_instruction_ex<Test_cref> instruction_type;

    typedef mfast::make_message_cref<Test_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<Test_mref, instruction_type> mref_type;
    Test(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    Test(
      const Test_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit Test(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    Test(const Test&);
    Test& operator = (const Test&);
};


struct  templates_description
  : mfast::templates_description
{
  typedef std::tuple<Unused1,
                       Test> types;
  templates_description();
  static const templates_description* instance();
};

inline const templates_description* description()
{
  return templates_description::instance();
}

#include "simple4.inl"
}
