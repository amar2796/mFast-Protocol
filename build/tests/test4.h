// test4.h generated by mFAST from FAST Template. 
// Do not modify this file directly. Any modifications 
// will be lost the next time this file is generated.

#pragma once

#include <mfast.h>
namespace test4
{

class Address_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::group_instruction_ex<Address_cref> instruction_type;

    typedef const instruction_type* instruction_cptr;
    Address_cref();
    template <typename T>
    Address_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, Address_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    explicit Address_cref(const mfast::field_cref& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_streetAddress() const;
    mfast::ascii_string_cref try_get_streetAddress() const;
    mfast::ascii_string_cref get_city() const;
    mfast::ascii_string_cref try_get_city() const;
    mfast::ascii_string_cref get_state() const;
    mfast::ascii_string_cref try_get_state() const;
    mfast::uint32_cref get_postalCode() const;
    mfast::uint32_cref try_get_postalCode() const;
};


class Address_mref
  : public mfast::make_aggregate_mref<Address_cref>
{
  typedef mfast::make_aggregate_mref<Address_cref> base_type;
  public:
    Address_mref();
    template <typename T>
    Address_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, Address_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    explicit Address_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_mref set_streetAddress() const;
    mfast::ascii_string_mref set_city() const;
    mfast::ascii_string_mref set_state() const;
    mfast::uint32_mref set_postalCode() const;
};

class Address
  : private std::array<mfast::value_storage, 4>
  , public mfast::group_type
{
  private:
    typedef  std::array<mfast::value_storage, 4> base_array;
    typedef mfast::group_type base_type;
  public:
    typedef mfast::group_instruction_ex<Address_cref> instruction_type;

    typedef Address_cref cref_type;
    typedef Address_mref mref_type;
    Address(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    Address(
      const Address_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();

    Address(Address&&) BOOST_NOEXCEPT;
    Address(const Address&);
    Address& operator = (Address&&) BOOST_NOEXCEPT;
    Address& operator = (const Address&);
};

typedef mfast::make_sequence_cref<Address_cref, mfast::defined_element_sequence_trait> Addresses_cref;
typedef mfast::make_sequence_mref<Address_mref, mfast::defined_element_sequence_trait> Addresses_mref;
class Addresses
  : public mfast::sequence_type
{
  typedef mfast::sequence_type base_type;
  public:
    typedef Addresses_cref::instruction_type instruction_type;

    typedef Addresses_cref cref_type;
    typedef Addresses_mref mref_type;
    Addresses(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    Addresses(
      const Addresses_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    Addresses(const Addresses&);
    Addresses& operator = (const Addresses&);
};


class PhoneNumbers_element_cref
  : public mfast::sequence_element_cref
{
  typedef mfast::sequence_element_cref base_type;
  public:
    typedef mfast::sequence_instruction_ex<PhoneNumbers_element_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    PhoneNumbers_element_cref(
      const mfast::value_storage* storage,
      instruction_cptr            instruction);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_type() const;
    mfast::ascii_string_cref try_get_type() const;
    mfast::ascii_string_cref get_number() const;
    mfast::ascii_string_cref try_get_number() const;
};

typedef mfast::make_sequence_cref<PhoneNumbers_element_cref> PhoneNumbers_cref;

class PhoneNumbers_element_mref
  : public mfast::make_aggregate_mref<PhoneNumbers_element_cref>
{
  typedef mfast::make_aggregate_mref<PhoneNumbers_element_cref> base_type;
  public:
    PhoneNumbers_element_mref(
      mfast::allocator*     alloc,
      mfast::value_storage* storage,
      instruction_cptr      instruction);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_mref set_type() const;
    mfast::ascii_string_mref set_number() const;
};

typedef mfast::make_sequence_mref<PhoneNumbers_element_mref> PhoneNumbers_mref;
class PhoneNumbers
  : public mfast::sequence_type
{
  typedef mfast::sequence_type base_type;
  public:
    typedef PhoneNumbers_cref::instruction_type instruction_type;

    typedef PhoneNumbers_cref cref_type;
    typedef PhoneNumbers_mref mref_type;
    PhoneNumbers(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    PhoneNumbers(
      const PhoneNumbers_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    PhoneNumbers(const PhoneNumbers&);
    PhoneNumbers& operator = (const PhoneNumbers&);
};

typedef mfast::make_sequence_cref<mfast::ascii_string_cref, mfast::sole_element_sequence_trait> Emails_cref;
typedef mfast::make_sequence_mref<mfast::ascii_string_mref, mfast::sole_element_sequence_trait> Emails_mref;
class Emails
  : public mfast::sequence_type
{
  typedef mfast::sequence_type base_type;
  public:
    typedef Emails_cref::instruction_type instruction_type;

    typedef Emails_cref cref_type;
    typedef Emails_mref mref_type;
    Emails(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    Emails(
      const Emails_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    Emails(const Emails&);
    Emails& operator = (const Emails&);
};


class Config_element_cref
  : public mfast::sequence_element_cref
{
  typedef mfast::sequence_element_cref base_type;
  public:
    typedef mfast::sequence_instruction_ex<Config_element_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Config_element_cref(
      const mfast::value_storage* storage,
      instruction_cptr            instruction);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_name() const;
    mfast::ascii_string_cref try_get_name() const;

    class detail_cref
      : public mfast::aggregate_cref
    {
      typedef mfast::aggregate_cref base_type;
      public:
        typedef mfast::group_instruction_ex<detail_cref> instruction_type;

        typedef const instruction_type* instruction_cptr;
        detail_cref();
        template <typename T>
        detail_cref(
          typename std::enable_if<std::is_same<typename T::cref_type, detail_cref>::value, const mfast::value_storage*>::type storage,
          const T* instruction);

        explicit detail_cref(const mfast::field_cref& other);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::ascii_string_cref get_detail1() const;
        mfast::ascii_string_cref try_get_detail1() const;
        mfast::ascii_string_cref get_detail2() const;
        mfast::ascii_string_cref try_get_detail2() const;
    };

    detail_cref get_detail() const;
    detail_cref try_get_detail() const;
};

typedef mfast::make_sequence_cref<Config_element_cref> Config_cref;

class Config_element_mref
  : public mfast::make_aggregate_mref<Config_element_cref>
{
  typedef mfast::make_aggregate_mref<Config_element_cref> base_type;
  public:
    Config_element_mref(
      mfast::allocator*     alloc,
      mfast::value_storage* storage,
      instruction_cptr      instruction);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_mref set_name() const;

    class detail_mref
      : public mfast::make_aggregate_mref<Config_element_cref::detail_cref>
    {
      typedef mfast::make_aggregate_mref<Config_element_cref::detail_cref> base_type;
      public:
        detail_mref();
        template <typename T>
        detail_mref(
          mfast::allocator*       alloc,
          typename std::enable_if<std::is_same<typename T::cref_type, detail_cref>::value, mfast::value_storage*>::type   storage,
          const T* instruction);

        explicit detail_mref(const mfast::field_mref_base& other);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::ascii_string_mref set_detail1() const;
        mfast::ascii_string_mref set_detail2() const;
    };

    detail_mref set_detail() const;
};

typedef mfast::make_sequence_mref<Config_element_mref> Config_mref;
class Config
  : public mfast::sequence_type
{
  typedef mfast::sequence_type base_type;
  public:
    typedef Config_cref::instruction_type instruction_type;

    typedef Config_cref cref_type;
    typedef Config_mref mref_type;
    Config(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    Config(
      const Config_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    Config(const Config&);
    Config& operator = (const Config&);
};

struct Gender
{
  enum element {
    male,
    female
  };
  typedef mfast::enum_field_instruction_ex<Gender> instruction_type;
  static const instruction_type* instruction();
};

class Gender_cref
  : public mfast::enum_cref_ex<Gender_cref, Gender>
{
  public:
    typedef mfast::enum_cref_ex<Gender_cref, Gender> base_type;
    typedef Gender::element element_type;
    typedef Gender::instruction_type instruction_type;
    Gender_cref(
      const mfast::value_storage* storage=nullptr,
      instruction_cptr            instruction=nullptr);

    explicit Gender_cref(const field_cref& other);

    element_type value() const;

    bool is_male() const;
    bool is_female() const;
};

class Gender_mref
  : public mfast::enum_mref_ex<Gender_mref, Gender_cref>
{
  public:
    typedef  mfast::enum_mref_ex<Gender_mref, Gender_cref> base_type;
    typedef Gender::element element_type;
    Gender_mref(
      mfast::allocator*     alloc=nullptr,
      mfast::value_storage* storage=nullptr,
      instruction_cptr      instruction=nullptr);
    explicit Gender_mref(const mfast::field_mref_base& other);

    void as_male() const;
    void as_female() const;
};

struct DiscreteEnum
{
  enum element {
    One = 1,
    Three = 3,
    Five = 5
  };
  typedef mfast::enum_field_instruction_ex<DiscreteEnum> instruction_type;
  static const instruction_type* instruction();
};

class DiscreteEnum_cref
  : public mfast::enum_cref_ex<DiscreteEnum_cref, DiscreteEnum>
{
  public:
    typedef mfast::enum_cref_ex<DiscreteEnum_cref, DiscreteEnum> base_type;
    typedef DiscreteEnum::element element_type;
    typedef DiscreteEnum::instruction_type instruction_type;
    DiscreteEnum_cref(
      const mfast::value_storage* storage=nullptr,
      instruction_cptr            instruction=nullptr);

    explicit DiscreteEnum_cref(const field_cref& other);

    element_type value() const;

    bool is_One() const;
    bool is_Three() const;
    bool is_Five() const;
};

class DiscreteEnum_mref
  : public mfast::enum_mref_ex<DiscreteEnum_mref, DiscreteEnum_cref>
{
  public:
    typedef  mfast::enum_mref_ex<DiscreteEnum_mref, DiscreteEnum_cref> base_type;
    typedef DiscreteEnum::element element_type;
    DiscreteEnum_mref(
      mfast::allocator*     alloc=nullptr,
      mfast::value_storage* storage=nullptr,
      instruction_cptr      instruction=nullptr);
    explicit DiscreteEnum_mref(const mfast::field_mref_base& other);

    void as_One() const;
    void as_Three() const;
    void as_Five() const;
};


class Education_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::group_instruction_ex<Education_cref> instruction_type;

    typedef const instruction_type* instruction_cptr;
    Education_cref();
    template <typename T>
    Education_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, Education_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    explicit Education_cref(const mfast::field_cref& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_college() const;
    mfast::ascii_string_cref try_get_college() const;
    mfast::ascii_string_cref get_high_school() const;
    mfast::ascii_string_cref try_get_high_school() const;
    mfast::ascii_string_cref get_elementary_school() const;
    mfast::ascii_string_cref try_get_elementary_school() const;
};


class Education_mref
  : public mfast::make_aggregate_mref<Education_cref>
{
  typedef mfast::make_aggregate_mref<Education_cref> base_type;
  public:
    Education_mref();
    template <typename T>
    Education_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, Education_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    explicit Education_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_mref set_college() const;
    void omit_college() const;
    mfast::ascii_string_mref set_high_school() const;
    void omit_high_school() const;
    mfast::ascii_string_mref set_elementary_school() const;
    void omit_elementary_school() const;
};

class Education
  : private std::array<mfast::value_storage, 3>
  , public mfast::group_type
{
  private:
    typedef  std::array<mfast::value_storage, 3> base_array;
    typedef mfast::group_type base_type;
  public:
    typedef mfast::group_instruction_ex<Education_cref> instruction_type;

    typedef Education_cref cref_type;
    typedef Education_mref mref_type;
    Education(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    Education(
      const Education_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();

    Education(Education&&) BOOST_NOEXCEPT;
    Education(const Education&);
    Education& operator = (Education&&) BOOST_NOEXCEPT;
    Education& operator = (const Education&);
};


class Person_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::group_instruction_ex<Person_cref> instruction_type;

    typedef const instruction_type* instruction_cptr;
    Person_cref();
    template <typename T>
    Person_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, Person_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    explicit Person_cref(const mfast::field_cref& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::unicode_string_cref get_firstName() const;
    mfast::unicode_string_cref try_get_firstName() const;
    mfast::unicode_string_cref get_lastName() const;
    mfast::unicode_string_cref try_get_lastName() const;
    typedef Gender_cref gender_cref;
    gender_cref get_gender() const;
    gender_cref try_get_gender() const;
    mfast::uint32_cref get_age() const;
    mfast::uint32_cref try_get_age() const;
    typedef Addresses_cref addresses_cref;
    addresses_cref get_addresses() const;
    addresses_cref try_get_addresses() const;
    typedef PhoneNumbers_cref phoneNumbers_cref;
    phoneNumbers_cref get_phoneNumbers() const;
    phoneNumbers_cref try_get_phoneNumbers() const;
    typedef Emails_cref emails_cref;
    emails_cref get_emails() const;
    emails_cref try_get_emails() const;
    struct bloodType
    {
      enum element {
        A,
        B,
        AB,
        O
      };
      typedef mfast::enum_field_instruction_ex<bloodType> instruction_type;
      static const instruction_type* instruction();
    };

    class bloodType_cref
      : public mfast::enum_cref_ex<bloodType_cref, bloodType>
    {
      public:
        typedef mfast::enum_cref_ex<bloodType_cref, bloodType> base_type;
        typedef bloodType::element element_type;
        typedef bloodType::instruction_type instruction_type;
        bloodType_cref(
          const mfast::value_storage* storage=nullptr,
          instruction_cptr            instruction=nullptr);

        explicit bloodType_cref(const field_cref& other);

        element_type value() const;

        bool is_A() const;
        bool is_B() const;
        bool is_AB() const;
        bool is_O() const;
    };

    bloodType_cref get_bloodType() const;
    bloodType_cref try_get_bloodType() const;
    typedef mfast::boolean_cref married_cref;
    married_cref get_married() const;
    married_cref try_get_married() const;
    typedef DiscreteEnum_cref discrete_cref;
    discrete_cref get_discrete() const;
    discrete_cref try_get_discrete() const;
    mfast::decimal_cref get_salary() const;
    mfast::decimal_cref try_get_salary() const;
    mfast::byte_vector_cref get_id() const;
    mfast::byte_vector_cref try_get_id() const;
    typedef Education_cref education_cref;
    education_cref get_education() const;
    education_cref try_get_education() const;
    mfast::int32_vector_cref get_test_vector() const;
    mfast::int32_vector_cref try_get_test_vector() const;
    typedef mfast::make_sequence_cref<mfast::ascii_string_cref, mfast::sole_element_sequence_trait> twoDimSequence_element_cref;
    typedef mfast::make_sequence_cref<twoDimSequence_element_cref, mfast::sole_element_sequence_trait> twoDimSequence_cref;
    twoDimSequence_cref get_twoDimSequence() const;
    twoDimSequence_cref try_get_twoDimSequence() const;
};


class Person_mref
  : public mfast::make_aggregate_mref<Person_cref>
{
  typedef mfast::make_aggregate_mref<Person_cref> base_type;
  public:
    Person_mref();
    template <typename T>
    Person_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, Person_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    explicit Person_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::unicode_string_mref set_firstName() const;
    mfast::unicode_string_mref set_lastName() const;
    typedef Gender_mref gender_mref;
    gender_mref set_gender() const;
    mfast::uint32_mref set_age() const;
    typedef Addresses_mref addresses_mref;
    addresses_mref set_addresses() const;
    void omit_addresses() const;
    typedef PhoneNumbers_mref phoneNumbers_mref;
    phoneNumbers_mref set_phoneNumbers() const;
    typedef Emails_mref emails_mref;
    emails_mref set_emails() const;
    class bloodType_mref
      : public mfast::enum_mref_ex<bloodType_mref, bloodType_cref>
    {
      public:
        typedef  mfast::enum_mref_ex<bloodType_mref, bloodType_cref> base_type;
        typedef bloodType::element element_type;
        bloodType_mref(
          mfast::allocator*     alloc=nullptr,
          mfast::value_storage* storage=nullptr,
          instruction_cptr      instruction=nullptr);
        explicit bloodType_mref(const mfast::field_mref_base& other);

        void as_A() const;
        void as_B() const;
        void as_AB() const;
        void as_O() const;
    };

    bloodType_mref set_bloodType() const;
    typedef mfast::boolean_mref married_mref;
    married_mref set_married() const;
    typedef DiscreteEnum_mref discrete_mref;
    discrete_mref set_discrete() const;
    mfast::decimal_mref set_salary() const;
    mfast::byte_vector_mref set_id() const;
    typedef Education_mref education_mref;
    education_mref set_education() const;
    void omit_education() const;
    void link_education(const education_mref& ref) const;
    void unlink_education() const;
    mfast::int32_vector_mref set_test_vector() const;
    typedef mfast::make_sequence_mref<mfast::ascii_string_mref, mfast::sole_element_sequence_trait> twoDimSequence_element_mref;
    typedef mfast::make_sequence_mref<twoDimSequence_element_mref, mfast::sole_element_sequence_trait> twoDimSequence_mref;
    twoDimSequence_mref set_twoDimSequence() const;
};

class Person
  : private std::array<mfast::value_storage, 15>
  , public mfast::group_type
{
  private:
    typedef  std::array<mfast::value_storage, 15> base_array;
    typedef mfast::group_type base_type;
  public:
    typedef mfast::group_instruction_ex<Person_cref> instruction_type;

    typedef Person_cref cref_type;
    typedef Person_mref mref_type;
    Person(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    Person(
      const Person_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();

    Person(Person&&) BOOST_NOEXCEPT;
    Person(const Person&);
    Person& operator = (Person&&) BOOST_NOEXCEPT;
    Person& operator = (const Person&);
};


#include "test4.inl"
}
