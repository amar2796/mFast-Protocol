// test4.inl generated by mFAST from FAST Template. 
// Do not modify this file directly. Any modifications 
// will be lost the next time this file is generated.

inline
Address_cref::Address_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Address_cref::Address_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, Address_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Address_cref::Address_cref(
  const mfast::field_cref& other)
  : base_type(other)
{
}

template <typename Visitor>
inline void Address_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 0> > ((*this)[2]) );
  visitor.visit(ext_cref<uint32_cref, none_operator_tag, properties_type< 0> > ((*this)[3]) );
}

inline
Address_mref::Address_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Address_mref::Address_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, Address_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Address_mref::Address_mref(
  const mfast::field_mref_base& other)
  : base_type(other)
{
}

template <typename Visitor>
inline void Address_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 0> > ((*this)[2]) );
  visitor.visit(ext_mref<uint32_mref, none_operator_tag, properties_type< 0> > ((*this)[3]) );
}

inline
Address::Address(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
Address::Address(
  const Address_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

inline Address::cref_type
Address::ref() const
{
  return Address::cref_type(my_storage_.of_group.content_, instruction());
}

inline Address::cref_type
Address::cref() const
{
  return Address::cref_type(my_storage_.of_group.content_, instruction());
}

inline Address::mref_type
Address::ref()
{
  return Address::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Address::mref_type
Address::mref()
{
  return Address::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline
Address::Address(Address&& other) BOOST_NOEXCEPT
  : base_array(static_cast<const base_array&>(other))
  , base_type(std::move(other), this->data())
{
}

inline
Address::Address(const Address& other) 
  : base_type(other.allocator(), other.instruction(), this->data(), other.data())
{
}

inline Address&
Address::operator =(Address&& other) BOOST_NOEXCEPT
{
  base_type::assign(std::move(other), this->data());
  base_array::operator=(static_cast<const base_array&>(other));
  return *this;
}

inline Address&
Address::operator =(const Address& other)
{
  Address tmp(other);
  return this->operator=(std::move(tmp));
}

inline mfast::ascii_string_cref
Address_cref::get_streetAddress() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_cref
Address_cref::try_get_streetAddress() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_mref
Address_mref::set_streetAddress() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[0]);
}

inline mfast::ascii_string_cref
Address_cref::get_city() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[1]);
}

inline mfast::ascii_string_cref
Address_cref::try_get_city() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[1]);
}

inline mfast::ascii_string_mref
Address_mref::set_city() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[1]);
}

inline mfast::ascii_string_cref
Address_cref::get_state() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[2]);
}

inline mfast::ascii_string_cref
Address_cref::try_get_state() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[2]);
}

inline mfast::ascii_string_mref
Address_mref::set_state() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[2]);
}

inline mfast::uint32_cref
Address_cref::get_postalCode() const
{
  return static_cast<mfast::uint32_cref>((*this)[3]);
}

inline mfast::uint32_cref
Address_cref::try_get_postalCode() const
{
  return static_cast<mfast::uint32_cref>((*this)[3]);
}

inline mfast::uint32_mref
Address_mref::set_postalCode() const
{
  return static_cast<mfast::uint32_mref>((*this)[3]);
}

inline
Addresses::Addresses(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), nullptr)
{
}

inline
Addresses::Addresses(
  const Addresses_cref& other,
  mfast::allocator* alloc)
  : base_type(reinterpret_cast<const mfast::sequence_cref&>(other), alloc)
{
}

inline Addresses::cref_type
Addresses::ref() const
{
  return Addresses::cref_type(&my_storage_, instruction());
}

inline Addresses::cref_type
Addresses::cref() const
{
  return Addresses::cref_type(&my_storage_, instruction());
}

inline Addresses::mref_type
Addresses::ref()
{
  return Addresses::mref_type(alloc_, &my_storage_, instruction());
}

inline Addresses::mref_type
Addresses::mref()
{
  return Addresses::mref_type(alloc_, &my_storage_, instruction());
}

inline
PhoneNumbers_element_cref::PhoneNumbers_element_cref(
  const mfast::value_storage*   storage,
  PhoneNumbers_element_cref::instruction_cptr instruction)
  : base_type(storage, instruction)
{
}

inline
PhoneNumbers_element_mref::PhoneNumbers_element_mref(
  mfast::allocator*               alloc,
  mfast::value_storage*         storage,
  PhoneNumbers_element_mref::instruction_cptr instruction)
  : base_type(alloc,storage, instruction)
{
}

template <typename Visitor>
inline void PhoneNumbers_element_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
}

template <typename Visitor>
inline void PhoneNumbers_element_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
}

inline mfast::ascii_string_cref
PhoneNumbers_element_cref::get_type() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_cref
PhoneNumbers_element_cref::try_get_type() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_mref
PhoneNumbers_element_mref::set_type() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[0]);
}

inline mfast::ascii_string_cref
PhoneNumbers_element_cref::get_number() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[1]);
}

inline mfast::ascii_string_cref
PhoneNumbers_element_cref::try_get_number() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[1]);
}

inline mfast::ascii_string_mref
PhoneNumbers_element_mref::set_number() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[1]);
}

inline
PhoneNumbers::PhoneNumbers(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), nullptr)
{
}

inline
PhoneNumbers::PhoneNumbers(
  const PhoneNumbers_cref& other,
  mfast::allocator* alloc)
  : base_type(reinterpret_cast<const mfast::sequence_cref&>(other), alloc)
{
}

inline PhoneNumbers::cref_type
PhoneNumbers::ref() const
{
  return PhoneNumbers::cref_type(&my_storage_, instruction());
}

inline PhoneNumbers::cref_type
PhoneNumbers::cref() const
{
  return PhoneNumbers::cref_type(&my_storage_, instruction());
}

inline PhoneNumbers::mref_type
PhoneNumbers::ref()
{
  return PhoneNumbers::mref_type(alloc_, &my_storage_, instruction());
}

inline PhoneNumbers::mref_type
PhoneNumbers::mref()
{
  return PhoneNumbers::mref_type(alloc_, &my_storage_, instruction());
}

inline
Emails::Emails(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), nullptr)
{
}

inline
Emails::Emails(
  const Emails_cref& other,
  mfast::allocator* alloc)
  : base_type(reinterpret_cast<const mfast::sequence_cref&>(other), alloc)
{
}

inline Emails::cref_type
Emails::ref() const
{
  return Emails::cref_type(&my_storage_, instruction());
}

inline Emails::cref_type
Emails::cref() const
{
  return Emails::cref_type(&my_storage_, instruction());
}

inline Emails::mref_type
Emails::ref()
{
  return Emails::mref_type(alloc_, &my_storage_, instruction());
}

inline Emails::mref_type
Emails::mref()
{
  return Emails::mref_type(alloc_, &my_storage_, instruction());
}

inline
Config_element_cref::Config_element_cref(
  const mfast::value_storage*   storage,
  Config_element_cref::instruction_cptr instruction)
  : base_type(storage, instruction)
{
}

inline
Config_element_mref::Config_element_mref(
  mfast::allocator*               alloc,
  mfast::value_storage*         storage,
  Config_element_mref::instruction_cptr instruction)
  : base_type(alloc,storage, instruction)
{
}

template <typename Visitor>
inline void Config_element_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_cref< detail_cref,  group_type_tag, properties_type< 0> > ((*this)[1]) );
}

template <typename Visitor>
inline void Config_element_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_mref< detail_mref, group_type_tag, properties_type< 0> > ((*this)[1]) );
}

inline mfast::ascii_string_cref
Config_element_cref::get_name() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_cref
Config_element_cref::try_get_name() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_mref
Config_element_mref::set_name() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[0]);
}


inline Config_element_cref::detail_cref
Config_element_cref::get_detail() const
{
  return static_cast<Config_element_cref::detail_cref>((*this)[1]);
}


inline Config_element_cref::detail_cref
Config_element_cref::try_get_detail() const
{
  return static_cast<Config_element_cref::detail_cref>((*this)[1]);
}

inline Config_element_mref::detail_mref
Config_element_mref::set_detail() const
{
  return Config_element_mref::detail_mref((*this)[1]);
}

inline
Config_element_cref::detail_cref::detail_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Config_element_cref::detail_cref::detail_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, detail_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Config_element_cref::detail_cref::detail_cref(
  const mfast::field_cref& other)
  : base_type(other)
{
}

template <typename Visitor>
inline void Config_element_cref::detail_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
}

inline
Config_element_mref::detail_mref::detail_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Config_element_mref::detail_mref::detail_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, detail_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Config_element_mref::detail_mref::detail_mref(
  const mfast::field_mref_base& other)
  : base_type(other)
{
}

template <typename Visitor>
inline void Config_element_mref::detail_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
}

inline mfast::ascii_string_cref
Config_element_cref::detail_cref::get_detail1() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_cref
Config_element_cref::detail_cref::try_get_detail1() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_mref
Config_element_mref::detail_mref::set_detail1() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[0]);
}

inline mfast::ascii_string_cref
Config_element_cref::detail_cref::get_detail2() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[1]);
}

inline mfast::ascii_string_cref
Config_element_cref::detail_cref::try_get_detail2() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[1]);
}

inline mfast::ascii_string_mref
Config_element_mref::detail_mref::set_detail2() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[1]);
}

inline
Config::Config(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), nullptr)
{
}

inline
Config::Config(
  const Config_cref& other,
  mfast::allocator* alloc)
  : base_type(reinterpret_cast<const mfast::sequence_cref&>(other), alloc)
{
}

inline Config::cref_type
Config::ref() const
{
  return Config::cref_type(&my_storage_, instruction());
}

inline Config::cref_type
Config::cref() const
{
  return Config::cref_type(&my_storage_, instruction());
}

inline Config::mref_type
Config::ref()
{
  return Config::mref_type(alloc_, &my_storage_, instruction());
}

inline Config::mref_type
Config::mref()
{
  return Config::mref_type(alloc_, &my_storage_, instruction());
}

inline
Gender_cref::Gender_cref(
  const mfast::value_storage*   storage,
  Gender_cref::instruction_cptr instruction)
  : base_type(storage, instruction)
{
}

inline
Gender_cref::Gender_cref(
  const mfast::field_cref& other)
  : base_type(other)
{
}

inline
Gender_mref::Gender_mref(
  mfast::allocator*      alloc,
  mfast::value_storage*  storage,
  Gender_mref::instruction_cptr instruction)
  : base_type(alloc, storage, instruction)
{
}

inline
Gender_mref::Gender_mref(
  const mfast::field_mref_base& other)
  : base_type(other)
{
}

inline
Gender_cref::element_type
Gender_cref::value() const
{
  return static_cast<Gender::element>(base_type::value());
}

inline
bool Gender_cref::is_male() const
{
  return this->value() == Gender::male;
}

inline
void Gender_mref::as_male() const
{
  return this->as(Gender::male);
}

inline
bool Gender_cref::is_female() const
{
  return this->value() == Gender::female;
}

inline
void Gender_mref::as_female() const
{
  return this->as(Gender::female);
}

inline
DiscreteEnum_cref::DiscreteEnum_cref(
  const mfast::value_storage*   storage,
  DiscreteEnum_cref::instruction_cptr instruction)
  : base_type(storage, instruction)
{
}

inline
DiscreteEnum_cref::DiscreteEnum_cref(
  const mfast::field_cref& other)
  : base_type(other)
{
}

inline
DiscreteEnum_mref::DiscreteEnum_mref(
  mfast::allocator*      alloc,
  mfast::value_storage*  storage,
  DiscreteEnum_mref::instruction_cptr instruction)
  : base_type(alloc, storage, instruction)
{
}

inline
DiscreteEnum_mref::DiscreteEnum_mref(
  const mfast::field_mref_base& other)
  : base_type(other)
{
}

inline
DiscreteEnum_cref::element_type
DiscreteEnum_cref::value() const
{
  return static_cast<DiscreteEnum::element>(base_type::value());
}

inline
bool DiscreteEnum_cref::is_One() const
{
  return this->value() == DiscreteEnum::One;
}

inline
void DiscreteEnum_mref::as_One() const
{
  return this->as(DiscreteEnum::One);
}

inline
bool DiscreteEnum_cref::is_Three() const
{
  return this->value() == DiscreteEnum::Three;
}

inline
void DiscreteEnum_mref::as_Three() const
{
  return this->as(DiscreteEnum::Three);
}

inline
bool DiscreteEnum_cref::is_Five() const
{
  return this->value() == DiscreteEnum::Five;
}

inline
void DiscreteEnum_mref::as_Five() const
{
  return this->as(DiscreteEnum::Five);
}

inline
Education_cref::Education_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Education_cref::Education_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, Education_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Education_cref::Education_cref(
  const mfast::field_cref& other)
  : base_type(other)
{
}

template <typename Visitor>
inline void Education_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 1> > ((*this)[0]) );
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 1> > ((*this)[1]) );
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 1> > ((*this)[2]) );
}

inline
Education_mref::Education_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Education_mref::Education_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, Education_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Education_mref::Education_mref(
  const mfast::field_mref_base& other)
  : base_type(other)
{
}

template <typename Visitor>
inline void Education_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 1> > ((*this)[0]) );
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 1> > ((*this)[1]) );
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 1> > ((*this)[2]) );
}

inline
Education::Education(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
Education::Education(
  const Education_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

inline Education::cref_type
Education::ref() const
{
  return Education::cref_type(my_storage_.of_group.content_, instruction());
}

inline Education::cref_type
Education::cref() const
{
  return Education::cref_type(my_storage_.of_group.content_, instruction());
}

inline Education::mref_type
Education::ref()
{
  return Education::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Education::mref_type
Education::mref()
{
  return Education::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline
Education::Education(Education&& other) BOOST_NOEXCEPT
  : base_array(static_cast<const base_array&>(other))
  , base_type(std::move(other), this->data())
{
}

inline
Education::Education(const Education& other) 
  : base_type(other.allocator(), other.instruction(), this->data(), other.data())
{
}

inline Education&
Education::operator =(Education&& other) BOOST_NOEXCEPT
{
  base_type::assign(std::move(other), this->data());
  base_array::operator=(static_cast<const base_array&>(other));
  return *this;
}

inline Education&
Education::operator =(const Education& other)
{
  Education tmp(other);
  return this->operator=(std::move(tmp));
}

inline mfast::ascii_string_cref
Education_cref::get_college() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_cref
Education_cref::try_get_college() const
{
  if ((*this)[0].absent())
    throw mfast::bad_optional_access();
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_mref
Education_mref::set_college() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[0]);
}

inline
void
Education_mref::omit_college() const
{
  (*this)[0].omit();
}

inline mfast::ascii_string_cref
Education_cref::get_high_school() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[1]);
}

inline mfast::ascii_string_cref
Education_cref::try_get_high_school() const
{
  if ((*this)[1].absent())
    throw mfast::bad_optional_access();
  return static_cast<mfast::ascii_string_cref>((*this)[1]);
}

inline mfast::ascii_string_mref
Education_mref::set_high_school() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[1]);
}

inline
void
Education_mref::omit_high_school() const
{
  (*this)[1].omit();
}

inline mfast::ascii_string_cref
Education_cref::get_elementary_school() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[2]);
}

inline mfast::ascii_string_cref
Education_cref::try_get_elementary_school() const
{
  if ((*this)[2].absent())
    throw mfast::bad_optional_access();
  return static_cast<mfast::ascii_string_cref>((*this)[2]);
}

inline mfast::ascii_string_mref
Education_mref::set_elementary_school() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[2]);
}

inline
void
Education_mref::omit_elementary_school() const
{
  (*this)[2].omit();
}

inline
Person_cref::Person_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Person_cref::Person_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, Person_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Person_cref::Person_cref(
  const mfast::field_cref& other)
  : base_type(other)
{
}

template <typename Visitor>
inline void Person_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<unicode_string_cref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_cref<unicode_string_cref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
  visitor.visit(ext_cref<enum_cref, default_operator_tag, properties_type< 2> > ((*this)[2]) );
  visitor.visit(ext_cref<uint32_cref, none_operator_tag, properties_type< 0> > ((*this)[3]) );
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, none_operator_tag, properties_type< 1> >, ext_cref< typename addresses_cref::reference, none_operator_tag, properties_type< 0>  > > ((*this)[4]) );
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, none_operator_tag, properties_type< 0> >, ext_cref< typename phoneNumbers_cref::reference, sequence_element_tag,properties_type< 0> > > ((*this)[5]) );
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, none_operator_tag, properties_type< 0> >, ext_cref< typename emails_cref::reference, none_operator_tag, properties_type< 0>  > > ((*this)[6]) );
  visitor.visit(ext_cref<enum_cref, none_operator_tag, properties_type< 2> > ((*this)[7]) );
  visitor.visit(ext_cref<enum_cref, none_operator_tag, properties_type< 2> > ((*this)[8]) );
  visitor.visit(ext_cref<enum_cref, copy_operator_tag, properties_type< 2> > ((*this)[9]) );
  visitor.visit(ext_cref<decimal_cref, std::tuple<constant_operator_tag, none_operator_tag>, std::tuple<properties_type< 2> , properties_type< 2> > > ((*this)[10]) );
  visitor.visit(ext_cref<byte_vector_cref, default_operator_tag, properties_type< 2> > ((*this)[11]) );
  {
    ext_cref< education_cref,  group_type_tag, properties_type< 1> > ext_cref_group((*this)[12]);
    ext_cref_group.set_group_present(this->field_storage(12)->is_present());
    visitor.visit(ext_cref_group);
  }
  visitor.visit(ext_cref< int32_vector_cref, none_operator_tag, properties_type< 0> > ((*this)[13]) );
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, none_operator_tag, properties_type< 0> >, ext_cref< typename twoDimSequence_cref::reference, none_operator_tag, properties_type< 0>  > > ((*this)[14]) );
}

inline
Person_mref::Person_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Person_mref::Person_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, Person_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Person_mref::Person_mref(
  const mfast::field_mref_base& other)
  : base_type(other)
{
}

template <typename Visitor>
inline void Person_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<unicode_string_mref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_mref<unicode_string_mref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
  visitor.visit(ext_mref<enum_mref, default_operator_tag, properties_type< 2> > ((*this)[2]) );
  visitor.visit(ext_mref<uint32_mref, none_operator_tag, properties_type< 0> > ((*this)[3]) );
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, none_operator_tag, properties_type< 1> >, ext_mref< typename addresses_mref::reference, none_operator_tag, properties_type< 0>  > > ((*this)[4]) );
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, none_operator_tag, properties_type< 0> >, ext_mref< typename phoneNumbers_mref::reference, sequence_element_tag,properties_type< 0> > > ((*this)[5]) );
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, none_operator_tag, properties_type< 0> >, ext_mref< typename emails_mref::reference, none_operator_tag, properties_type< 0>  > > ((*this)[6]) );
  visitor.visit(ext_mref<enum_mref, none_operator_tag, properties_type< 2> > ((*this)[7]) );
  visitor.visit(ext_mref<enum_mref, none_operator_tag, properties_type< 2> > ((*this)[8]) );
  visitor.visit(ext_mref<enum_mref, copy_operator_tag, properties_type< 2> > ((*this)[9]) );
  visitor.visit(ext_mref<decimal_mref, std::tuple<constant_operator_tag, none_operator_tag>, std::tuple<properties_type< 2> , properties_type< 2> > > ((*this)[10]) );
  visitor.visit(ext_mref<byte_vector_mref, default_operator_tag, properties_type< 2> > ((*this)[11]) );
  visitor.visit(ext_mref< education_mref, group_type_tag, properties_type< 1> > ((*this)[12]) );
  visitor.visit(ext_mref<int32_vector_mref, none_operator_tag, properties_type< 0> > ((*this)[13]) );
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, none_operator_tag, properties_type< 0> >, ext_mref< typename twoDimSequence_mref::reference, none_operator_tag, properties_type< 0>  > > ((*this)[14]) );
}

inline
Person::Person(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
Person::Person(
  const Person_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

inline Person::cref_type
Person::ref() const
{
  return Person::cref_type(my_storage_.of_group.content_, instruction());
}

inline Person::cref_type
Person::cref() const
{
  return Person::cref_type(my_storage_.of_group.content_, instruction());
}

inline Person::mref_type
Person::ref()
{
  return Person::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Person::mref_type
Person::mref()
{
  return Person::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline
Person::Person(Person&& other) BOOST_NOEXCEPT
  : base_array(static_cast<const base_array&>(other))
  , base_type(std::move(other), this->data())
{
}

inline
Person::Person(const Person& other) 
  : base_type(other.allocator(), other.instruction(), this->data(), other.data())
{
}

inline Person&
Person::operator =(Person&& other) BOOST_NOEXCEPT
{
  base_type::assign(std::move(other), this->data());
  base_array::operator=(static_cast<const base_array&>(other));
  return *this;
}

inline Person&
Person::operator =(const Person& other)
{
  Person tmp(other);
  return this->operator=(std::move(tmp));
}

inline mfast::unicode_string_cref
Person_cref::get_firstName() const
{
  return static_cast<mfast::unicode_string_cref>((*this)[0]);
}

inline mfast::unicode_string_cref
Person_cref::try_get_firstName() const
{
  return static_cast<mfast::unicode_string_cref>((*this)[0]);
}

inline mfast::unicode_string_mref
Person_mref::set_firstName() const
{
  return static_cast<mfast::unicode_string_mref>((*this)[0]);
}

inline mfast::unicode_string_cref
Person_cref::get_lastName() const
{
  return static_cast<mfast::unicode_string_cref>((*this)[1]);
}

inline mfast::unicode_string_cref
Person_cref::try_get_lastName() const
{
  return static_cast<mfast::unicode_string_cref>((*this)[1]);
}

inline mfast::unicode_string_mref
Person_mref::set_lastName() const
{
  return static_cast<mfast::unicode_string_mref>((*this)[1]);
}

inline Person_cref::gender_cref
Person_cref::get_gender() const
{
  return static_cast<Person_cref::gender_cref>((*this)[2]);
}

inline Person_cref::gender_cref
Person_cref::try_get_gender() const
{
  return static_cast<Person_cref::gender_cref>((*this)[2]);
}

inline Person_mref::gender_mref
Person_mref::set_gender() const
{
  return static_cast<Person_mref::gender_mref>((*this)[2]);
}

inline mfast::uint32_cref
Person_cref::get_age() const
{
  return static_cast<mfast::uint32_cref>((*this)[3]);
}

inline mfast::uint32_cref
Person_cref::try_get_age() const
{
  return static_cast<mfast::uint32_cref>((*this)[3]);
}

inline mfast::uint32_mref
Person_mref::set_age() const
{
  return static_cast<mfast::uint32_mref>((*this)[3]);
}

inline Person_cref::addresses_cref
Person_cref::get_addresses() const
{
  return static_cast<Person_cref::addresses_cref>((*this)[4]);
}

inline Person_cref::addresses_cref
Person_cref::try_get_addresses() const
{
  if ((*this)[4].absent())
    throw mfast::bad_optional_access();
  return static_cast<Person_cref::addresses_cref>((*this)[4]);
}

inline Person_mref::addresses_mref
Person_mref::set_addresses() const
{
  return static_cast<Person_mref::addresses_mref>((*this)[4]);
}

inline
void
Person_mref::omit_addresses() const
{
  (*this)[4].omit();
}

inline Person_cref::phoneNumbers_cref
Person_cref::get_phoneNumbers() const
{
  return static_cast<Person_cref::phoneNumbers_cref>((*this)[5]);
}

inline Person_cref::phoneNumbers_cref
Person_cref::try_get_phoneNumbers() const
{
  return static_cast<Person_cref::phoneNumbers_cref>((*this)[5]);
}

inline Person_mref::phoneNumbers_mref
Person_mref::set_phoneNumbers() const
{
  return static_cast<Person_mref::phoneNumbers_mref>((*this)[5]);
}

inline Person_cref::emails_cref
Person_cref::get_emails() const
{
  return static_cast<Person_cref::emails_cref>((*this)[6]);
}

inline Person_cref::emails_cref
Person_cref::try_get_emails() const
{
  return static_cast<Person_cref::emails_cref>((*this)[6]);
}

inline Person_mref::emails_mref
Person_mref::set_emails() const
{
  return static_cast<Person_mref::emails_mref>((*this)[6]);
}

inline
Person_cref::bloodType_cref::bloodType_cref(
  const mfast::value_storage*   storage,
  Person_cref::bloodType_cref::instruction_cptr instruction)
  : base_type(storage, instruction)
{
}

inline
Person_cref::bloodType_cref::bloodType_cref(
  const mfast::field_cref& other)
  : base_type(other)
{
}

inline
Person_mref::bloodType_mref::bloodType_mref(
  mfast::allocator*      alloc,
  mfast::value_storage*  storage,
  Person_mref::bloodType_mref::instruction_cptr instruction)
  : base_type(alloc, storage, instruction)
{
}

inline
Person_mref::bloodType_mref::bloodType_mref(
  const mfast::field_mref_base& other)
  : base_type(other)
{
}

inline
Person_cref::bloodType_cref::element_type
Person_cref::bloodType_cref::value() const
{
  return static_cast<bloodType::element>(base_type::value());
}

inline
bool Person_cref::bloodType_cref::is_A() const
{
  return this->value() == bloodType::A;
}

inline
void Person_mref::bloodType_mref::as_A() const
{
  return this->as(bloodType::A);
}

inline
bool Person_cref::bloodType_cref::is_B() const
{
  return this->value() == bloodType::B;
}

inline
void Person_mref::bloodType_mref::as_B() const
{
  return this->as(bloodType::B);
}

inline
bool Person_cref::bloodType_cref::is_AB() const
{
  return this->value() == bloodType::AB;
}

inline
void Person_mref::bloodType_mref::as_AB() const
{
  return this->as(bloodType::AB);
}

inline
bool Person_cref::bloodType_cref::is_O() const
{
  return this->value() == bloodType::O;
}

inline
void Person_mref::bloodType_mref::as_O() const
{
  return this->as(bloodType::O);
}

inline Person_cref::bloodType_cref
Person_cref::get_bloodType() const
{
  return static_cast<Person_cref::bloodType_cref>((*this)[7]);
}

inline Person_cref::bloodType_cref
Person_cref::try_get_bloodType() const
{
  return static_cast<Person_cref::bloodType_cref>((*this)[7]);
}

inline Person_mref::bloodType_mref
Person_mref::set_bloodType() const
{
  return static_cast<Person_mref::bloodType_mref>((*this)[7]);
}

inline Person_cref::married_cref
Person_cref::get_married() const
{
  return static_cast<Person_cref::married_cref>((*this)[8]);
}

inline Person_cref::married_cref
Person_cref::try_get_married() const
{
  return static_cast<Person_cref::married_cref>((*this)[8]);
}

inline Person_mref::married_mref
Person_mref::set_married() const
{
  return static_cast<Person_mref::married_mref>((*this)[8]);
}

inline Person_cref::discrete_cref
Person_cref::get_discrete() const
{
  return static_cast<Person_cref::discrete_cref>((*this)[9]);
}

inline Person_cref::discrete_cref
Person_cref::try_get_discrete() const
{
  return static_cast<Person_cref::discrete_cref>((*this)[9]);
}

inline Person_mref::discrete_mref
Person_mref::set_discrete() const
{
  return static_cast<Person_mref::discrete_mref>((*this)[9]);
}

inline mfast::decimal_cref
Person_cref::get_salary() const
{
  return static_cast<mfast::decimal_cref>((*this)[10]);
}

inline mfast::decimal_cref
Person_cref::try_get_salary() const
{
  return static_cast<mfast::decimal_cref>((*this)[10]);
}

inline mfast::decimal_mref
Person_mref::set_salary() const
{
  return static_cast<mfast::decimal_mref>((*this)[10]);
}

inline mfast::byte_vector_cref
Person_cref::get_id() const
{
  return static_cast<mfast::byte_vector_cref>((*this)[11]);
}

inline mfast::byte_vector_cref
Person_cref::try_get_id() const
{
  return static_cast<mfast::byte_vector_cref>((*this)[11]);
}

inline mfast::byte_vector_mref
Person_mref::set_id() const
{
  return static_cast<mfast::byte_vector_mref>((*this)[11]);
}


inline Person_cref::education_cref
Person_cref::get_education() const
{
  if ((*this)[12].absent())
    return Person_cref::education_cref(nullptr, Person_cref::education_cref::instruction_cptr(nullptr));
  return static_cast<Person_cref::education_cref>((*this)[12]);
}


inline Person_cref::education_cref
Person_cref::try_get_education() const
{
  if ((*this)[12].absent())
    throw mfast::bad_optional_access();
  return static_cast<Person_cref::education_cref>((*this)[12]);
}

inline Person_mref::education_mref
Person_mref::set_education() const
{
  this->field_storage(12)->present(true);
  return Person_mref::education_mref((*this)[12]);
}

inline
void
Person_mref::omit_education() const
{
  (*this)[12].omit();
}

inline void
Person_mref::link_education(const Person_mref::education_mref& ref) const
{
  this->link_group_at(12, ref);
}

inline void
Person_mref::unlink_education() const
{
  this->unlink_group_at(12);
}

inline mfast::int32_vector_cref
Person_cref::get_test_vector() const
{
  return static_cast<mfast::int32_vector_cref>((*this)[13]);
}

inline mfast::int32_vector_cref
Person_cref::try_get_test_vector() const
{
  return static_cast<mfast::int32_vector_cref>((*this)[13]);
}

inline mfast::int32_vector_mref
Person_mref::set_test_vector() const
{
  return static_cast<mfast::int32_vector_mref>((*this)[13]);
}

inline Person_cref::twoDimSequence_cref
Person_cref::get_twoDimSequence() const
{
  return static_cast<Person_cref::twoDimSequence_cref>((*this)[14]);
}

inline Person_cref::twoDimSequence_cref
Person_cref::try_get_twoDimSequence() const
{
  return static_cast<Person_cref::twoDimSequence_cref>((*this)[14]);
}

inline Person_mref::twoDimSequence_mref
Person_mref::set_twoDimSequence() const
{
  return static_cast<Person_mref::twoDimSequence_mref>((*this)[14]);
}

