// test2.h generated by mFAST from FAST Template. 
// Do not modify this file directly. Any modifications 
// will be lost the next time this file is generated.

#pragma once

#include <mfast.h>
#include "test1.h"
namespace test2
{

class StandardTrailer_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<StandardTrailer_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    StandardTrailer_cref();
    template <typename T>
    StandardTrailer_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, StandardTrailer_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    StandardTrailer_cref(const mfast::message_cref& other);

    explicit StandardTrailer_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);


};


typedef mfast::make_aggregate_mref<StandardTrailer_cref> StandardTrailer_mref_base;
class StandardTrailer_mref
  : public StandardTrailer_mref_base
{
  typedef StandardTrailer_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<StandardTrailer_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    StandardTrailer_mref();
    template <typename T>
    StandardTrailer_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, StandardTrailer_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    StandardTrailer_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit StandardTrailer_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

};

class StandardTrailer
  : private mfast::value_storage_array<0>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 0
    };
    typedef mfast::template_instruction_ex<StandardTrailer_cref> instruction_type;

    typedef mfast::make_message_cref<StandardTrailer_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<StandardTrailer_mref, instruction_type> mref_type;
    StandardTrailer(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    StandardTrailer(
      const StandardTrailer_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit StandardTrailer(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    StandardTrailer(const StandardTrailer&);
    StandardTrailer& operator = (const StandardTrailer&);
};


class MDRefreshSample_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<MDRefreshSample_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    MDRefreshSample_cref();
    template <typename T>
    MDRefreshSample_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, MDRefreshSample_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    MDRefreshSample_cref(const mfast::message_cref& other);

    explicit MDRefreshSample_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    typedef test1::SampleInfo_cref info_cref;
    info_cref get_info() const;
    info_cref try_get_info() const;

    class MDEntries_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<MDEntries_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        MDEntries_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_cref get_MDUpdateAction() const;
        mfast::uint32_cref try_get_MDUpdateAction() const;
        mfast::ascii_string_cref get_MDEntryType() const;
        mfast::ascii_string_cref try_get_MDEntryType() const;
        mfast::ascii_string_cref get_Symbol() const;
        mfast::ascii_string_cref try_get_Symbol() const;
        mfast::ascii_string_cref get_SecurityType() const;
        mfast::ascii_string_cref try_get_SecurityType() const;
        mfast::decimal_cref get_MDEntryPx() const;
        mfast::decimal_cref try_get_MDEntryPx() const;
        mfast::decimal_cref get_MDEntrySize() const;
        mfast::decimal_cref try_get_MDEntrySize() const;
        mfast::uint32_cref get_NumberOfOrders() const;
        mfast::uint32_cref try_get_NumberOfOrders() const;
        mfast::ascii_string_cref get_QuoteCondition() const;
        mfast::ascii_string_cref try_get_QuoteCondition() const;
        mfast::ascii_string_cref get_TradeCondition() const;
        mfast::ascii_string_cref try_get_TradeCondition() const;
        mfast::unicode_string_cref get_SecurityID() const;
        mfast::unicode_string_cref try_get_SecurityID() const;
        mfast::ascii_string_cref get_OrderStatus() const;
        mfast::ascii_string_cref try_get_OrderStatus() const;
        mfast::unicode_string_cref get_EncodedIssuer() const;
        mfast::unicode_string_cref try_get_EncodedIssuer() const;
        mfast::byte_vector_cref get_EncodedSecurityDesc() const;
        mfast::byte_vector_cref try_get_EncodedSecurityDesc() const;
    };

    typedef mfast::make_sequence_cref<MDEntries_element_cref> MDEntries_cref;
    MDEntries_cref get_MDEntries() const;
    MDEntries_cref try_get_MDEntries() const;
    typedef mfast::make_sequence_cref<test1::SampleInfo_cref, mfast::defined_element_sequence_trait> extra_cref;
    extra_cref get_extra() const;
    extra_cref try_get_extra() const;

};


typedef mfast::make_aggregate_mref<MDRefreshSample_cref> MDRefreshSample_mref_base;
class MDRefreshSample_mref
  : public MDRefreshSample_mref_base
{
  typedef MDRefreshSample_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<MDRefreshSample_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    MDRefreshSample_mref();
    template <typename T>
    MDRefreshSample_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, MDRefreshSample_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    MDRefreshSample_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit MDRefreshSample_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    typedef test1::SampleInfo_mref info_mref;
    info_mref set_info() const;
    void link_info(const info_mref& ref) const;
    void unlink_info() const;

    class MDEntries_element_mref
      : public mfast::make_aggregate_mref<MDRefreshSample_cref::MDEntries_element_cref>
    {
      typedef mfast::make_aggregate_mref<MDRefreshSample_cref::MDEntries_element_cref> base_type;
      public:
        MDEntries_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_mref set_MDUpdateAction() const;
        mfast::ascii_string_mref set_MDEntryType() const;
        mfast::ascii_string_mref set_Symbol() const;
        mfast::ascii_string_mref set_SecurityType() const;
        mfast::decimal_mref set_MDEntryPx() const;
        mfast::decimal_mref set_MDEntrySize() const;
        mfast::uint32_mref set_NumberOfOrders() const;
        mfast::ascii_string_mref set_QuoteCondition() const;
        mfast::ascii_string_mref set_TradeCondition() const;
        mfast::unicode_string_mref set_SecurityID() const;
        void omit_SecurityID() const;
        mfast::ascii_string_mref set_OrderStatus() const;
        void omit_OrderStatus() const;
        mfast::unicode_string_mref set_EncodedIssuer() const;
        mfast::byte_vector_mref set_EncodedSecurityDesc() const;
    };

    typedef mfast::make_sequence_mref<MDEntries_element_mref> MDEntries_mref;
    MDEntries_mref set_MDEntries() const;
    typedef mfast::make_sequence_mref<test1::SampleInfo_mref, mfast::defined_element_sequence_trait> extra_mref;
    extra_mref set_extra() const;
};

class MDRefreshSample
  : private mfast::value_storage_array<3>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 2
    };
    typedef mfast::template_instruction_ex<MDRefreshSample_cref> instruction_type;

    typedef mfast::make_message_cref<MDRefreshSample_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<MDRefreshSample_mref, instruction_type> mref_type;
    MDRefreshSample(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    MDRefreshSample(
      const MDRefreshSample_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit MDRefreshSample(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    MDRefreshSample(const MDRefreshSample&);
    MDRefreshSample& operator = (const MDRefreshSample&);
};


class _0_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<_0_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    _0_cref();
    template <typename T>
    _0_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, _0_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    _0_cref(const mfast::message_cref& other);

    explicit _0_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MessageType() const;
    mfast::ascii_string_cref try_get_MessageType() const;
    mfast::ascii_string_cref get_BeginString() const;
    mfast::ascii_string_cref try_get_BeginString() const;
    mfast::ascii_string_cref get_SenderCompID() const;
    mfast::ascii_string_cref try_get_SenderCompID() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint64_cref get_SendingTime() const;
    mfast::uint64_cref try_get_SendingTime() const;

};


typedef mfast::make_aggregate_mref<_0_cref> _0_mref_base;
class _0_mref
  : public _0_mref_base
{
  typedef _0_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<_0_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    _0_mref();
    template <typename T>
    _0_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, _0_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    _0_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit _0_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    mfast::uint64_mref set_SendingTime() const;
};

class _0
  : private mfast::value_storage_array<5>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 2008
    };
    typedef mfast::template_instruction_ex<_0_cref> instruction_type;

    typedef mfast::make_message_cref<_0_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<_0_mref, instruction_type> mref_type;
    _0(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    _0(
      const _0_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit _0(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    _0(const _0&);
    _0& operator = (const _0&);
};


class With_dash_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<With_dash_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    With_dash_cref();
    template <typename T>
    With_dash_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, With_dash_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    With_dash_cref(const mfast::message_cref& other);

    explicit With_dash_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MessageType() const;
    mfast::ascii_string_cref try_get_MessageType() const;
    mfast::ascii_string_cref get_BeginString() const;
    mfast::ascii_string_cref try_get_BeginString() const;
    mfast::ascii_string_cref get_SenderCompID() const;
    mfast::ascii_string_cref try_get_SenderCompID() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint64_cref get_SendingTime() const;
    mfast::uint64_cref try_get_SendingTime() const;

};


typedef mfast::make_aggregate_mref<With_dash_cref> With_dash_mref_base;
class With_dash_mref
  : public With_dash_mref_base
{
  typedef With_dash_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<With_dash_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    With_dash_mref();
    template <typename T>
    With_dash_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, With_dash_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    With_dash_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit With_dash_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    mfast::uint64_mref set_SendingTime() const;
};

class With_dash
  : private mfast::value_storage_array<5>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 2009
    };
    typedef mfast::template_instruction_ex<With_dash_cref> instruction_type;

    typedef mfast::make_message_cref<With_dash_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<With_dash_mref, instruction_type> mref_type;
    With_dash(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    With_dash(
      const With_dash_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit With_dash(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    With_dash(const With_dash&);
    With_dash& operator = (const With_dash&);
};


struct  templates_description
  : mfast::templates_description
{
  typedef std::tuple<MDRefreshSample,
                       _0,
                       With_dash> types;
  templates_description();
  static const templates_description* instance();
};

inline const templates_description* description()
{
  return templates_description::instance();
}

#include "test2.inl"
}
