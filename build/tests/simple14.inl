// simple14.inl generated by mFAST from FAST Template. 
// Do not modify this file directly. Any modifications 
// will be lost the next time this file is generated.

inline
Test_1_cref::Test_1_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Test_1_cref::Test_1_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, Test_1_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Test_1_cref::Test_1_cref(
  const mfast::message_cref& other)
  : base_type(other)
{
}

inline
Test_1_cref::Test_1_cref(
  const mfast::field_cref& other)
  : base_type(mfast::field_cref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Test_1_cref::operator mfast::message_cref()
{
  return mfast::message_cref(this->storage(), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Test_1_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, copy_operator_tag, properties_type< 1> >, ext_cref< typename sequence_1_cref::reference, sequence_element_tag,properties_type< 2> > > ((*this)[0]) );
  visitor.visit(ext_cref<uint32_cref, none_operator_tag, properties_type< 1> > ((*this)[1]) );
}

inline
Test_1_mref::Test_1_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Test_1_mref::Test_1_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, Test_1_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Test_1_mref::Test_1_mref(
  const mfast::message_mref& other)
  : base_type(other)
{
}

inline
Test_1_mref::Test_1_mref(
  const mfast::field_mref_base& other)
  : base_type(other.allocator(),
              mfast::field_mref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Test_1_mref::operator mfast::message_mref()
{
  return mfast::message_mref(this->allocator(), const_cast<mfast::value_storage*>(this->storage()), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Test_1_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, copy_operator_tag, properties_type< 1> >, ext_mref< typename sequence_1_mref::reference, sequence_element_tag,properties_type< 2> > > ((*this)[0]) );
  visitor.visit(ext_mref<uint32_mref, none_operator_tag, properties_type< 1> > ((*this)[1]) );
}

inline
Test_1::Test_1(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
Test_1::Test_1(
  const Test_1_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

#ifdef MFAST_JSON_H
Test_1::Test_1(
  const char* json_initializer,
  int json_object_tag_mask,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
  std::stringstream strm(json_initializer);
  mfast::json::decode(strm, this->mref(), json_object_tag_mask);
}

#endif
inline Test_1::cref_type
Test_1::ref() const
{
  return Test_1::cref_type(my_storage_.of_group.content_, instruction());
}

inline Test_1::cref_type
Test_1::cref() const
{
  return Test_1::cref_type(my_storage_.of_group.content_, instruction());
}

inline Test_1::mref_type
Test_1::ref()
{
  return Test_1::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Test_1::mref_type
Test_1::mref()
{
  return Test_1::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Test_1_cref::sequence_1_cref
Test_1_cref::get_sequence_1() const
{
  return static_cast<Test_1_cref::sequence_1_cref>((*this)[0]);
}

inline Test_1_cref::sequence_1_cref
Test_1_cref::try_get_sequence_1() const
{
  if ((*this)[0].absent())
    throw mfast::bad_optional_access();
  return static_cast<Test_1_cref::sequence_1_cref>((*this)[0]);
}

inline Test_1_mref::sequence_1_mref
Test_1_mref::set_sequence_1() const
{
  return static_cast<Test_1_mref::sequence_1_mref>((*this)[0]);
}

inline
void
Test_1_mref::omit_sequence_1() const
{
  (*this)[0].omit();
}

inline
Test_1_cref::sequence_1_element_cref::sequence_1_element_cref(
  const mfast::value_storage*   storage,
  Test_1_cref::sequence_1_element_cref::instruction_cptr instruction)
  : base_type(storage, instruction)
{
}

inline
Test_1_mref::sequence_1_element_mref::sequence_1_element_mref(
  mfast::allocator*               alloc,
  mfast::value_storage*         storage,
  Test_1_mref::sequence_1_element_mref::instruction_cptr instruction)
  : base_type(alloc,storage, instruction)
{
}

template <typename Visitor>
inline void Test_1_cref::sequence_1_element_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<uint32_cref, copy_operator_tag, properties_type< 1> > ((*this)[0]) );
}

template <typename Visitor>
inline void Test_1_mref::sequence_1_element_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<uint32_mref, copy_operator_tag, properties_type< 1> > ((*this)[0]) );
}

inline mfast::uint32_cref
Test_1_cref::sequence_1_element_cref::get_field_1_2() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_cref
Test_1_cref::sequence_1_element_cref::try_get_field_1_2() const
{
  if ((*this)[0].absent())
    throw mfast::bad_optional_access();
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_mref
Test_1_mref::sequence_1_element_mref::set_field_1_2() const
{
  return static_cast<mfast::uint32_mref>((*this)[0]);
}

inline
void
Test_1_mref::sequence_1_element_mref::omit_field_1_2() const
{
  (*this)[0].omit();
}

inline mfast::uint32_cref
Test_1_cref::get_field_1_3() const
{
  return static_cast<mfast::uint32_cref>((*this)[1]);
}

inline mfast::uint32_cref
Test_1_cref::try_get_field_1_3() const
{
  if ((*this)[1].absent())
    throw mfast::bad_optional_access();
  return static_cast<mfast::uint32_cref>((*this)[1]);
}

inline mfast::uint32_mref
Test_1_mref::set_field_1_3() const
{
  return static_cast<mfast::uint32_mref>((*this)[1]);
}

inline
void
Test_1_mref::omit_field_1_3() const
{
  (*this)[1].omit();
}

inline
Test_2_cref::Test_2_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Test_2_cref::Test_2_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, Test_2_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Test_2_cref::Test_2_cref(
  const mfast::message_cref& other)
  : base_type(other)
{
}

inline
Test_2_cref::Test_2_cref(
  const mfast::field_cref& other)
  : base_type(mfast::field_cref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Test_2_cref::operator mfast::message_cref()
{
  return mfast::message_cref(this->storage(), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Test_2_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, constant_operator_tag, properties_type< 3> >, ext_cref< typename sequence_2_cref::reference, sequence_element_tag,properties_type< 2> > > ((*this)[0]) );
  visitor.visit(ext_cref<uint32_cref, none_operator_tag, properties_type< 1> > ((*this)[1]) );
}

inline
Test_2_mref::Test_2_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Test_2_mref::Test_2_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, Test_2_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Test_2_mref::Test_2_mref(
  const mfast::message_mref& other)
  : base_type(other)
{
}

inline
Test_2_mref::Test_2_mref(
  const mfast::field_mref_base& other)
  : base_type(other.allocator(),
              mfast::field_mref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Test_2_mref::operator mfast::message_mref()
{
  return mfast::message_mref(this->allocator(), const_cast<mfast::value_storage*>(this->storage()), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Test_2_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, constant_operator_tag, properties_type< 3> >, ext_mref< typename sequence_2_mref::reference, sequence_element_tag,properties_type< 2> > > ((*this)[0]) );
  visitor.visit(ext_mref<uint32_mref, none_operator_tag, properties_type< 1> > ((*this)[1]) );
}

inline
Test_2::Test_2(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
Test_2::Test_2(
  const Test_2_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

#ifdef MFAST_JSON_H
Test_2::Test_2(
  const char* json_initializer,
  int json_object_tag_mask,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
  std::stringstream strm(json_initializer);
  mfast::json::decode(strm, this->mref(), json_object_tag_mask);
}

#endif
inline Test_2::cref_type
Test_2::ref() const
{
  return Test_2::cref_type(my_storage_.of_group.content_, instruction());
}

inline Test_2::cref_type
Test_2::cref() const
{
  return Test_2::cref_type(my_storage_.of_group.content_, instruction());
}

inline Test_2::mref_type
Test_2::ref()
{
  return Test_2::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Test_2::mref_type
Test_2::mref()
{
  return Test_2::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Test_2_cref::sequence_2_cref
Test_2_cref::get_sequence_2() const
{
  return static_cast<Test_2_cref::sequence_2_cref>((*this)[0]);
}

inline Test_2_cref::sequence_2_cref
Test_2_cref::try_get_sequence_2() const
{
  if ((*this)[0].absent())
    throw mfast::bad_optional_access();
  return static_cast<Test_2_cref::sequence_2_cref>((*this)[0]);
}

inline Test_2_mref::sequence_2_mref
Test_2_mref::set_sequence_2() const
{
  return static_cast<Test_2_mref::sequence_2_mref>((*this)[0]);
}

inline
void
Test_2_mref::omit_sequence_2() const
{
  (*this)[0].omit();
}

inline
Test_2_cref::sequence_2_element_cref::sequence_2_element_cref(
  const mfast::value_storage*   storage,
  Test_2_cref::sequence_2_element_cref::instruction_cptr instruction)
  : base_type(storage, instruction)
{
}

inline
Test_2_mref::sequence_2_element_mref::sequence_2_element_mref(
  mfast::allocator*               alloc,
  mfast::value_storage*         storage,
  Test_2_mref::sequence_2_element_mref::instruction_cptr instruction)
  : base_type(alloc,storage, instruction)
{
}

template <typename Visitor>
inline void Test_2_cref::sequence_2_element_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<uint32_cref, copy_operator_tag, properties_type< 1> > ((*this)[0]) );
}

template <typename Visitor>
inline void Test_2_mref::sequence_2_element_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<uint32_mref, copy_operator_tag, properties_type< 1> > ((*this)[0]) );
}

inline mfast::uint32_cref
Test_2_cref::sequence_2_element_cref::get_field_2_2() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_cref
Test_2_cref::sequence_2_element_cref::try_get_field_2_2() const
{
  if ((*this)[0].absent())
    throw mfast::bad_optional_access();
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_mref
Test_2_mref::sequence_2_element_mref::set_field_2_2() const
{
  return static_cast<mfast::uint32_mref>((*this)[0]);
}

inline
void
Test_2_mref::sequence_2_element_mref::omit_field_2_2() const
{
  (*this)[0].omit();
}

inline mfast::uint32_cref
Test_2_cref::get_field_2_3() const
{
  return static_cast<mfast::uint32_cref>((*this)[1]);
}

inline mfast::uint32_cref
Test_2_cref::try_get_field_2_3() const
{
  if ((*this)[1].absent())
    throw mfast::bad_optional_access();
  return static_cast<mfast::uint32_cref>((*this)[1]);
}

inline mfast::uint32_mref
Test_2_mref::set_field_2_3() const
{
  return static_cast<mfast::uint32_mref>((*this)[1]);
}

inline
void
Test_2_mref::omit_field_2_3() const
{
  (*this)[1].omit();
}

inline
Test_3_cref::Test_3_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Test_3_cref::Test_3_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, Test_3_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Test_3_cref::Test_3_cref(
  const mfast::message_cref& other)
  : base_type(other)
{
}

inline
Test_3_cref::Test_3_cref(
  const mfast::field_cref& other)
  : base_type(mfast::field_cref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Test_3_cref::operator mfast::message_cref()
{
  return mfast::message_cref(this->storage(), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Test_3_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, default_operator_tag, properties_type< 3> >, ext_cref< typename sequence_3_cref::reference, sequence_element_tag,properties_type< 2> > > ((*this)[0]) );
  visitor.visit(ext_cref<uint32_cref, none_operator_tag, properties_type< 1> > ((*this)[1]) );
}

inline
Test_3_mref::Test_3_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Test_3_mref::Test_3_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, Test_3_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Test_3_mref::Test_3_mref(
  const mfast::message_mref& other)
  : base_type(other)
{
}

inline
Test_3_mref::Test_3_mref(
  const mfast::field_mref_base& other)
  : base_type(other.allocator(),
              mfast::field_mref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Test_3_mref::operator mfast::message_mref()
{
  return mfast::message_mref(this->allocator(), const_cast<mfast::value_storage*>(this->storage()), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Test_3_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, default_operator_tag, properties_type< 3> >, ext_mref< typename sequence_3_mref::reference, sequence_element_tag,properties_type< 2> > > ((*this)[0]) );
  visitor.visit(ext_mref<uint32_mref, none_operator_tag, properties_type< 1> > ((*this)[1]) );
}

inline
Test_3::Test_3(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
Test_3::Test_3(
  const Test_3_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

#ifdef MFAST_JSON_H
Test_3::Test_3(
  const char* json_initializer,
  int json_object_tag_mask,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
  std::stringstream strm(json_initializer);
  mfast::json::decode(strm, this->mref(), json_object_tag_mask);
}

#endif
inline Test_3::cref_type
Test_3::ref() const
{
  return Test_3::cref_type(my_storage_.of_group.content_, instruction());
}

inline Test_3::cref_type
Test_3::cref() const
{
  return Test_3::cref_type(my_storage_.of_group.content_, instruction());
}

inline Test_3::mref_type
Test_3::ref()
{
  return Test_3::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Test_3::mref_type
Test_3::mref()
{
  return Test_3::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Test_3_cref::sequence_3_cref
Test_3_cref::get_sequence_3() const
{
  return static_cast<Test_3_cref::sequence_3_cref>((*this)[0]);
}

inline Test_3_cref::sequence_3_cref
Test_3_cref::try_get_sequence_3() const
{
  if ((*this)[0].absent())
    throw mfast::bad_optional_access();
  return static_cast<Test_3_cref::sequence_3_cref>((*this)[0]);
}

inline Test_3_mref::sequence_3_mref
Test_3_mref::set_sequence_3() const
{
  return static_cast<Test_3_mref::sequence_3_mref>((*this)[0]);
}

inline
void
Test_3_mref::omit_sequence_3() const
{
  (*this)[0].omit();
}

inline
Test_3_cref::sequence_3_element_cref::sequence_3_element_cref(
  const mfast::value_storage*   storage,
  Test_3_cref::sequence_3_element_cref::instruction_cptr instruction)
  : base_type(storage, instruction)
{
}

inline
Test_3_mref::sequence_3_element_mref::sequence_3_element_mref(
  mfast::allocator*               alloc,
  mfast::value_storage*         storage,
  Test_3_mref::sequence_3_element_mref::instruction_cptr instruction)
  : base_type(alloc,storage, instruction)
{
}

template <typename Visitor>
inline void Test_3_cref::sequence_3_element_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<uint32_cref, copy_operator_tag, properties_type< 1> > ((*this)[0]) );
}

template <typename Visitor>
inline void Test_3_mref::sequence_3_element_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<uint32_mref, copy_operator_tag, properties_type< 1> > ((*this)[0]) );
}

inline mfast::uint32_cref
Test_3_cref::sequence_3_element_cref::get_field_3_2() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_cref
Test_3_cref::sequence_3_element_cref::try_get_field_3_2() const
{
  if ((*this)[0].absent())
    throw mfast::bad_optional_access();
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_mref
Test_3_mref::sequence_3_element_mref::set_field_3_2() const
{
  return static_cast<mfast::uint32_mref>((*this)[0]);
}

inline
void
Test_3_mref::sequence_3_element_mref::omit_field_3_2() const
{
  (*this)[0].omit();
}

inline mfast::uint32_cref
Test_3_cref::get_field_3_3() const
{
  return static_cast<mfast::uint32_cref>((*this)[1]);
}

inline mfast::uint32_cref
Test_3_cref::try_get_field_3_3() const
{
  if ((*this)[1].absent())
    throw mfast::bad_optional_access();
  return static_cast<mfast::uint32_cref>((*this)[1]);
}

inline mfast::uint32_mref
Test_3_mref::set_field_3_3() const
{
  return static_cast<mfast::uint32_mref>((*this)[1]);
}

inline
void
Test_3_mref::omit_field_3_3() const
{
  (*this)[1].omit();
}

inline
Test_4_cref::Test_4_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Test_4_cref::Test_4_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, Test_4_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Test_4_cref::Test_4_cref(
  const mfast::message_cref& other)
  : base_type(other)
{
}

inline
Test_4_cref::Test_4_cref(
  const mfast::field_cref& other)
  : base_type(mfast::field_cref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Test_4_cref::operator mfast::message_cref()
{
  return mfast::message_cref(this->storage(), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Test_4_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, none_operator_tag, properties_type< 1> >, ext_cref< typename sequence_4_cref::reference, sequence_element_tag,properties_type< 2> > > ((*this)[0]) );
  visitor.visit(ext_cref<uint32_cref, none_operator_tag, properties_type< 1> > ((*this)[1]) );
}

inline
Test_4_mref::Test_4_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Test_4_mref::Test_4_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, Test_4_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Test_4_mref::Test_4_mref(
  const mfast::message_mref& other)
  : base_type(other)
{
}

inline
Test_4_mref::Test_4_mref(
  const mfast::field_mref_base& other)
  : base_type(other.allocator(),
              mfast::field_mref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Test_4_mref::operator mfast::message_mref()
{
  return mfast::message_mref(this->allocator(), const_cast<mfast::value_storage*>(this->storage()), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Test_4_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, none_operator_tag, properties_type< 1> >, ext_mref< typename sequence_4_mref::reference, sequence_element_tag,properties_type< 2> > > ((*this)[0]) );
  visitor.visit(ext_mref<uint32_mref, none_operator_tag, properties_type< 1> > ((*this)[1]) );
}

inline
Test_4::Test_4(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
Test_4::Test_4(
  const Test_4_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

#ifdef MFAST_JSON_H
Test_4::Test_4(
  const char* json_initializer,
  int json_object_tag_mask,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
  std::stringstream strm(json_initializer);
  mfast::json::decode(strm, this->mref(), json_object_tag_mask);
}

#endif
inline Test_4::cref_type
Test_4::ref() const
{
  return Test_4::cref_type(my_storage_.of_group.content_, instruction());
}

inline Test_4::cref_type
Test_4::cref() const
{
  return Test_4::cref_type(my_storage_.of_group.content_, instruction());
}

inline Test_4::mref_type
Test_4::ref()
{
  return Test_4::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Test_4::mref_type
Test_4::mref()
{
  return Test_4::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Test_4_cref::sequence_4_cref
Test_4_cref::get_sequence_4() const
{
  return static_cast<Test_4_cref::sequence_4_cref>((*this)[0]);
}

inline Test_4_cref::sequence_4_cref
Test_4_cref::try_get_sequence_4() const
{
  if ((*this)[0].absent())
    throw mfast::bad_optional_access();
  return static_cast<Test_4_cref::sequence_4_cref>((*this)[0]);
}

inline Test_4_mref::sequence_4_mref
Test_4_mref::set_sequence_4() const
{
  return static_cast<Test_4_mref::sequence_4_mref>((*this)[0]);
}

inline
void
Test_4_mref::omit_sequence_4() const
{
  (*this)[0].omit();
}

inline
Test_4_cref::sequence_4_element_cref::sequence_4_element_cref(
  const mfast::value_storage*   storage,
  Test_4_cref::sequence_4_element_cref::instruction_cptr instruction)
  : base_type(storage, instruction)
{
}

inline
Test_4_mref::sequence_4_element_mref::sequence_4_element_mref(
  mfast::allocator*               alloc,
  mfast::value_storage*         storage,
  Test_4_mref::sequence_4_element_mref::instruction_cptr instruction)
  : base_type(alloc,storage, instruction)
{
}

template <typename Visitor>
inline void Test_4_cref::sequence_4_element_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<uint32_cref, copy_operator_tag, properties_type< 1> > ((*this)[0]) );
}

template <typename Visitor>
inline void Test_4_mref::sequence_4_element_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<uint32_mref, copy_operator_tag, properties_type< 1> > ((*this)[0]) );
}

inline mfast::uint32_cref
Test_4_cref::sequence_4_element_cref::get_field_4_2() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_cref
Test_4_cref::sequence_4_element_cref::try_get_field_4_2() const
{
  if ((*this)[0].absent())
    throw mfast::bad_optional_access();
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_mref
Test_4_mref::sequence_4_element_mref::set_field_4_2() const
{
  return static_cast<mfast::uint32_mref>((*this)[0]);
}

inline
void
Test_4_mref::sequence_4_element_mref::omit_field_4_2() const
{
  (*this)[0].omit();
}

inline mfast::uint32_cref
Test_4_cref::get_field_4_3() const
{
  return static_cast<mfast::uint32_cref>((*this)[1]);
}

inline mfast::uint32_cref
Test_4_cref::try_get_field_4_3() const
{
  if ((*this)[1].absent())
    throw mfast::bad_optional_access();
  return static_cast<mfast::uint32_cref>((*this)[1]);
}

inline mfast::uint32_mref
Test_4_mref::set_field_4_3() const
{
  return static_cast<mfast::uint32_mref>((*this)[1]);
}

inline
void
Test_4_mref::omit_field_4_3() const
{
  (*this)[1].omit();
}

inline
Test_5_cref::Test_5_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Test_5_cref::Test_5_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, Test_5_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Test_5_cref::Test_5_cref(
  const mfast::message_cref& other)
  : base_type(other)
{
}

inline
Test_5_cref::Test_5_cref(
  const mfast::field_cref& other)
  : base_type(mfast::field_cref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Test_5_cref::operator mfast::message_cref()
{
  return mfast::message_cref(this->storage(), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Test_5_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<uint32_cref, copy_operator_tag, properties_type< 1> > ((*this)[0]) );
  visitor.visit(ext_cref<uint32_cref, copy_operator_tag, properties_type< 0> > ((*this)[1]) );
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, none_operator_tag, properties_type< 0> >, ext_cref< typename sequence_5_1_cref::reference, sequence_element_tag,properties_type< 4> > > ((*this)[2]) );
}

inline
Test_5_mref::Test_5_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Test_5_mref::Test_5_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, Test_5_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Test_5_mref::Test_5_mref(
  const mfast::message_mref& other)
  : base_type(other)
{
}

inline
Test_5_mref::Test_5_mref(
  const mfast::field_mref_base& other)
  : base_type(other.allocator(),
              mfast::field_mref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Test_5_mref::operator mfast::message_mref()
{
  return mfast::message_mref(this->allocator(), const_cast<mfast::value_storage*>(this->storage()), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Test_5_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<uint32_mref, copy_operator_tag, properties_type< 1> > ((*this)[0]) );
  visitor.visit(ext_mref<uint32_mref, copy_operator_tag, properties_type< 0> > ((*this)[1]) );
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, none_operator_tag, properties_type< 0> >, ext_mref< typename sequence_5_1_mref::reference, sequence_element_tag,properties_type< 4> > > ((*this)[2]) );
}

inline
Test_5::Test_5(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
Test_5::Test_5(
  const Test_5_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

#ifdef MFAST_JSON_H
Test_5::Test_5(
  const char* json_initializer,
  int json_object_tag_mask,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
  std::stringstream strm(json_initializer);
  mfast::json::decode(strm, this->mref(), json_object_tag_mask);
}

#endif
inline Test_5::cref_type
Test_5::ref() const
{
  return Test_5::cref_type(my_storage_.of_group.content_, instruction());
}

inline Test_5::cref_type
Test_5::cref() const
{
  return Test_5::cref_type(my_storage_.of_group.content_, instruction());
}

inline Test_5::mref_type
Test_5::ref()
{
  return Test_5::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Test_5::mref_type
Test_5::mref()
{
  return Test_5::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline mfast::uint32_cref
Test_5_cref::get_field_5_1() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_cref
Test_5_cref::try_get_field_5_1() const
{
  if ((*this)[0].absent())
    throw mfast::bad_optional_access();
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_mref
Test_5_mref::set_field_5_1() const
{
  return static_cast<mfast::uint32_mref>((*this)[0]);
}

inline
void
Test_5_mref::omit_field_5_1() const
{
  (*this)[0].omit();
}

inline mfast::uint32_cref
Test_5_cref::get_field_5_2() const
{
  return static_cast<mfast::uint32_cref>((*this)[1]);
}

inline mfast::uint32_cref
Test_5_cref::try_get_field_5_2() const
{
  return static_cast<mfast::uint32_cref>((*this)[1]);
}

inline mfast::uint32_mref
Test_5_mref::set_field_5_2() const
{
  return static_cast<mfast::uint32_mref>((*this)[1]);
}

inline Test_5_cref::sequence_5_1_cref
Test_5_cref::get_sequence_5_1() const
{
  return static_cast<Test_5_cref::sequence_5_1_cref>((*this)[2]);
}

inline Test_5_cref::sequence_5_1_cref
Test_5_cref::try_get_sequence_5_1() const
{
  return static_cast<Test_5_cref::sequence_5_1_cref>((*this)[2]);
}

inline Test_5_mref::sequence_5_1_mref
Test_5_mref::set_sequence_5_1() const
{
  return static_cast<Test_5_mref::sequence_5_1_mref>((*this)[2]);
}

inline
Test_5_cref::sequence_5_1_element_cref::sequence_5_1_element_cref(
  const mfast::value_storage*   storage,
  Test_5_cref::sequence_5_1_element_cref::instruction_cptr instruction)
  : base_type(storage, instruction)
{
}

inline
Test_5_mref::sequence_5_1_element_mref::sequence_5_1_element_mref(
  mfast::allocator*               alloc,
  mfast::value_storage*         storage,
  Test_5_mref::sequence_5_1_element_mref::instruction_cptr instruction)
  : base_type(alloc,storage, instruction)
{
}

template <typename Visitor>
inline void Test_5_cref::sequence_5_1_element_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<uint32_cref, copy_operator_tag, properties_type< 1> > ((*this)[0]) );
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, copy_operator_tag, properties_type< 1> >, ext_cref< typename sequence_5_2_cref::reference, sequence_element_tag,properties_type< 0> > > ((*this)[1]) );
}

template <typename Visitor>
inline void Test_5_mref::sequence_5_1_element_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<uint32_mref, copy_operator_tag, properties_type< 1> > ((*this)[0]) );
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, copy_operator_tag, properties_type< 1> >, ext_mref< typename sequence_5_2_mref::reference, sequence_element_tag,properties_type< 0> > > ((*this)[1]) );
}

inline mfast::uint32_cref
Test_5_cref::sequence_5_1_element_cref::get_field_5_4() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_cref
Test_5_cref::sequence_5_1_element_cref::try_get_field_5_4() const
{
  if ((*this)[0].absent())
    throw mfast::bad_optional_access();
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_mref
Test_5_mref::sequence_5_1_element_mref::set_field_5_4() const
{
  return static_cast<mfast::uint32_mref>((*this)[0]);
}

inline
void
Test_5_mref::sequence_5_1_element_mref::omit_field_5_4() const
{
  (*this)[0].omit();
}

inline Test_5_cref::sequence_5_1_element_cref::sequence_5_2_cref
Test_5_cref::sequence_5_1_element_cref::get_sequence_5_2() const
{
  return static_cast<Test_5_cref::sequence_5_1_element_cref::sequence_5_2_cref>((*this)[1]);
}

inline Test_5_cref::sequence_5_1_element_cref::sequence_5_2_cref
Test_5_cref::sequence_5_1_element_cref::try_get_sequence_5_2() const
{
  if ((*this)[1].absent())
    throw mfast::bad_optional_access();
  return static_cast<Test_5_cref::sequence_5_1_element_cref::sequence_5_2_cref>((*this)[1]);
}

inline Test_5_mref::sequence_5_1_element_mref::sequence_5_2_mref
Test_5_mref::sequence_5_1_element_mref::set_sequence_5_2() const
{
  return static_cast<Test_5_mref::sequence_5_1_element_mref::sequence_5_2_mref>((*this)[1]);
}

inline
void
Test_5_mref::sequence_5_1_element_mref::omit_sequence_5_2() const
{
  (*this)[1].omit();
}

inline
Test_5_cref::sequence_5_1_element_cref::sequence_5_2_element_cref::sequence_5_2_element_cref(
  const mfast::value_storage*   storage,
  Test_5_cref::sequence_5_1_element_cref::sequence_5_2_element_cref::instruction_cptr instruction)
  : base_type(storage, instruction)
{
}

inline
Test_5_mref::sequence_5_1_element_mref::sequence_5_2_element_mref::sequence_5_2_element_mref(
  mfast::allocator*               alloc,
  mfast::value_storage*         storage,
  Test_5_mref::sequence_5_1_element_mref::sequence_5_2_element_mref::instruction_cptr instruction)
  : base_type(alloc,storage, instruction)
{
}

template <typename Visitor>
inline void Test_5_cref::sequence_5_1_element_cref::sequence_5_2_element_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<uint32_cref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
}

template <typename Visitor>
inline void Test_5_mref::sequence_5_1_element_mref::sequence_5_2_element_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<uint32_mref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
}

inline mfast::uint32_cref
Test_5_cref::sequence_5_1_element_cref::sequence_5_2_element_cref::get_field_5_6() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_cref
Test_5_cref::sequence_5_1_element_cref::sequence_5_2_element_cref::try_get_field_5_6() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_mref
Test_5_mref::sequence_5_1_element_mref::sequence_5_2_element_mref::set_field_5_6() const
{
  return static_cast<mfast::uint32_mref>((*this)[0]);
}

inline
Test_6_cref::Test_6_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Test_6_cref::Test_6_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, Test_6_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Test_6_cref::Test_6_cref(
  const mfast::message_cref& other)
  : base_type(other)
{
}

inline
Test_6_cref::Test_6_cref(
  const mfast::field_cref& other)
  : base_type(mfast::field_cref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Test_6_cref::operator mfast::message_cref()
{
  return mfast::message_cref(this->storage(), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Test_6_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<uint32_cref, copy_operator_tag, properties_type< 1> > ((*this)[0]) );
  visitor.visit(ext_cref< group_6_cref,  group_type_tag, properties_type< 0> > ((*this)[1]) );
}

inline
Test_6_mref::Test_6_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Test_6_mref::Test_6_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, Test_6_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Test_6_mref::Test_6_mref(
  const mfast::message_mref& other)
  : base_type(other)
{
}

inline
Test_6_mref::Test_6_mref(
  const mfast::field_mref_base& other)
  : base_type(other.allocator(),
              mfast::field_mref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Test_6_mref::operator mfast::message_mref()
{
  return mfast::message_mref(this->allocator(), const_cast<mfast::value_storage*>(this->storage()), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Test_6_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<uint32_mref, copy_operator_tag, properties_type< 1> > ((*this)[0]) );
  visitor.visit(ext_mref< group_6_mref, group_type_tag, properties_type< 0> > ((*this)[1]) );
}

inline
Test_6::Test_6(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
Test_6::Test_6(
  const Test_6_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

#ifdef MFAST_JSON_H
Test_6::Test_6(
  const char* json_initializer,
  int json_object_tag_mask,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
  std::stringstream strm(json_initializer);
  mfast::json::decode(strm, this->mref(), json_object_tag_mask);
}

#endif
inline Test_6::cref_type
Test_6::ref() const
{
  return Test_6::cref_type(my_storage_.of_group.content_, instruction());
}

inline Test_6::cref_type
Test_6::cref() const
{
  return Test_6::cref_type(my_storage_.of_group.content_, instruction());
}

inline Test_6::mref_type
Test_6::ref()
{
  return Test_6::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Test_6::mref_type
Test_6::mref()
{
  return Test_6::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline mfast::uint32_cref
Test_6_cref::get_field_6_1() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_cref
Test_6_cref::try_get_field_6_1() const
{
  if ((*this)[0].absent())
    throw mfast::bad_optional_access();
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_mref
Test_6_mref::set_field_6_1() const
{
  return static_cast<mfast::uint32_mref>((*this)[0]);
}

inline
void
Test_6_mref::omit_field_6_1() const
{
  (*this)[0].omit();
}


inline Test_6_cref::group_6_cref
Test_6_cref::get_group_6() const
{
  return static_cast<Test_6_cref::group_6_cref>((*this)[1]);
}


inline Test_6_cref::group_6_cref
Test_6_cref::try_get_group_6() const
{
  return static_cast<Test_6_cref::group_6_cref>((*this)[1]);
}

inline Test_6_mref::group_6_mref
Test_6_mref::set_group_6() const
{
  return Test_6_mref::group_6_mref((*this)[1]);
}

inline
Test_6_cref::group_6_cref::group_6_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Test_6_cref::group_6_cref::group_6_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, group_6_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Test_6_cref::group_6_cref::group_6_cref(
  const mfast::field_cref& other)
  : base_type(other)
{
}

template <typename Visitor>
inline void Test_6_cref::group_6_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, none_operator_tag, properties_type< 0> >, ext_cref< typename sequence_6_1_cref::reference, sequence_element_tag,properties_type< 6> > > ((*this)[0]) );
}

inline
Test_6_mref::group_6_mref::group_6_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Test_6_mref::group_6_mref::group_6_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, group_6_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Test_6_mref::group_6_mref::group_6_mref(
  const mfast::field_mref_base& other)
  : base_type(other)
{
}

template <typename Visitor>
inline void Test_6_mref::group_6_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, none_operator_tag, properties_type< 0> >, ext_mref< typename sequence_6_1_mref::reference, sequence_element_tag,properties_type< 6> > > ((*this)[0]) );
}

inline Test_6_cref::group_6_cref::sequence_6_1_cref
Test_6_cref::group_6_cref::get_sequence_6_1() const
{
  return static_cast<Test_6_cref::group_6_cref::sequence_6_1_cref>((*this)[0]);
}

inline Test_6_cref::group_6_cref::sequence_6_1_cref
Test_6_cref::group_6_cref::try_get_sequence_6_1() const
{
  return static_cast<Test_6_cref::group_6_cref::sequence_6_1_cref>((*this)[0]);
}

inline Test_6_mref::group_6_mref::sequence_6_1_mref
Test_6_mref::group_6_mref::set_sequence_6_1() const
{
  return static_cast<Test_6_mref::group_6_mref::sequence_6_1_mref>((*this)[0]);
}

inline
Test_6_cref::group_6_cref::sequence_6_1_element_cref::sequence_6_1_element_cref(
  const mfast::value_storage*   storage,
  Test_6_cref::group_6_cref::sequence_6_1_element_cref::instruction_cptr instruction)
  : base_type(storage, instruction)
{
}

inline
Test_6_mref::group_6_mref::sequence_6_1_element_mref::sequence_6_1_element_mref(
  mfast::allocator*               alloc,
  mfast::value_storage*         storage,
  Test_6_mref::group_6_mref::sequence_6_1_element_mref::instruction_cptr instruction)
  : base_type(alloc,storage, instruction)
{
}

template <typename Visitor>
inline void Test_6_cref::group_6_cref::sequence_6_1_element_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<uint32_cref, copy_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_cref<uint32_cref, copy_operator_tag, properties_type< 1> > ((*this)[1]) );
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, copy_operator_tag, properties_type< 1> >, ext_cref< typename sequence_6_2_cref::reference, sequence_element_tag,properties_type< 0> > > ((*this)[2]) );
}

template <typename Visitor>
inline void Test_6_mref::group_6_mref::sequence_6_1_element_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<uint32_mref, copy_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_mref<uint32_mref, copy_operator_tag, properties_type< 1> > ((*this)[1]) );
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, copy_operator_tag, properties_type< 1> >, ext_mref< typename sequence_6_2_mref::reference, sequence_element_tag,properties_type< 0> > > ((*this)[2]) );
}

inline mfast::uint32_cref
Test_6_cref::group_6_cref::sequence_6_1_element_cref::get_field_6_3() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_cref
Test_6_cref::group_6_cref::sequence_6_1_element_cref::try_get_field_6_3() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_mref
Test_6_mref::group_6_mref::sequence_6_1_element_mref::set_field_6_3() const
{
  return static_cast<mfast::uint32_mref>((*this)[0]);
}

inline mfast::uint32_cref
Test_6_cref::group_6_cref::sequence_6_1_element_cref::get_field_6_4() const
{
  return static_cast<mfast::uint32_cref>((*this)[1]);
}

inline mfast::uint32_cref
Test_6_cref::group_6_cref::sequence_6_1_element_cref::try_get_field_6_4() const
{
  if ((*this)[1].absent())
    throw mfast::bad_optional_access();
  return static_cast<mfast::uint32_cref>((*this)[1]);
}

inline mfast::uint32_mref
Test_6_mref::group_6_mref::sequence_6_1_element_mref::set_field_6_4() const
{
  return static_cast<mfast::uint32_mref>((*this)[1]);
}

inline
void
Test_6_mref::group_6_mref::sequence_6_1_element_mref::omit_field_6_4() const
{
  (*this)[1].omit();
}

inline Test_6_cref::group_6_cref::sequence_6_1_element_cref::sequence_6_2_cref
Test_6_cref::group_6_cref::sequence_6_1_element_cref::get_sequence_6_2() const
{
  return static_cast<Test_6_cref::group_6_cref::sequence_6_1_element_cref::sequence_6_2_cref>((*this)[2]);
}

inline Test_6_cref::group_6_cref::sequence_6_1_element_cref::sequence_6_2_cref
Test_6_cref::group_6_cref::sequence_6_1_element_cref::try_get_sequence_6_2() const
{
  if ((*this)[2].absent())
    throw mfast::bad_optional_access();
  return static_cast<Test_6_cref::group_6_cref::sequence_6_1_element_cref::sequence_6_2_cref>((*this)[2]);
}

inline Test_6_mref::group_6_mref::sequence_6_1_element_mref::sequence_6_2_mref
Test_6_mref::group_6_mref::sequence_6_1_element_mref::set_sequence_6_2() const
{
  return static_cast<Test_6_mref::group_6_mref::sequence_6_1_element_mref::sequence_6_2_mref>((*this)[2]);
}

inline
void
Test_6_mref::group_6_mref::sequence_6_1_element_mref::omit_sequence_6_2() const
{
  (*this)[2].omit();
}

inline
Test_6_cref::group_6_cref::sequence_6_1_element_cref::sequence_6_2_element_cref::sequence_6_2_element_cref(
  const mfast::value_storage*   storage,
  Test_6_cref::group_6_cref::sequence_6_1_element_cref::sequence_6_2_element_cref::instruction_cptr instruction)
  : base_type(storage, instruction)
{
}

inline
Test_6_mref::group_6_mref::sequence_6_1_element_mref::sequence_6_2_element_mref::sequence_6_2_element_mref(
  mfast::allocator*               alloc,
  mfast::value_storage*         storage,
  Test_6_mref::group_6_mref::sequence_6_1_element_mref::sequence_6_2_element_mref::instruction_cptr instruction)
  : base_type(alloc,storage, instruction)
{
}

template <typename Visitor>
inline void Test_6_cref::group_6_cref::sequence_6_1_element_cref::sequence_6_2_element_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<uint32_cref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
}

template <typename Visitor>
inline void Test_6_mref::group_6_mref::sequence_6_1_element_mref::sequence_6_2_element_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<uint32_mref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
}

inline mfast::uint32_cref
Test_6_cref::group_6_cref::sequence_6_1_element_cref::sequence_6_2_element_cref::get_field_6_6() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_cref
Test_6_cref::group_6_cref::sequence_6_1_element_cref::sequence_6_2_element_cref::try_get_field_6_6() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_mref
Test_6_mref::group_6_mref::sequence_6_1_element_mref::sequence_6_2_element_mref::set_field_6_6() const
{
  return static_cast<mfast::uint32_mref>((*this)[0]);
}

inline
Test_7_cref::Test_7_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Test_7_cref::Test_7_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, Test_7_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Test_7_cref::Test_7_cref(
  const mfast::message_cref& other)
  : base_type(other)
{
}

inline
Test_7_cref::Test_7_cref(
  const mfast::field_cref& other)
  : base_type(mfast::field_cref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Test_7_cref::operator mfast::message_cref()
{
  return mfast::message_cref(this->storage(), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Test_7_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, none_operator_tag, properties_type< 0> >, ext_cref< typename sequence_7_cref::reference, sequence_element_tag,properties_type< 4> > > ((*this)[0]) );
}

inline
Test_7_mref::Test_7_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Test_7_mref::Test_7_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, Test_7_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Test_7_mref::Test_7_mref(
  const mfast::message_mref& other)
  : base_type(other)
{
}

inline
Test_7_mref::Test_7_mref(
  const mfast::field_mref_base& other)
  : base_type(other.allocator(),
              mfast::field_mref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Test_7_mref::operator mfast::message_mref()
{
  return mfast::message_mref(this->allocator(), const_cast<mfast::value_storage*>(this->storage()), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Test_7_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, none_operator_tag, properties_type< 0> >, ext_mref< typename sequence_7_mref::reference, sequence_element_tag,properties_type< 4> > > ((*this)[0]) );
}

inline
Test_7::Test_7(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
Test_7::Test_7(
  const Test_7_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

#ifdef MFAST_JSON_H
Test_7::Test_7(
  const char* json_initializer,
  int json_object_tag_mask,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
  std::stringstream strm(json_initializer);
  mfast::json::decode(strm, this->mref(), json_object_tag_mask);
}

#endif
inline Test_7::cref_type
Test_7::ref() const
{
  return Test_7::cref_type(my_storage_.of_group.content_, instruction());
}

inline Test_7::cref_type
Test_7::cref() const
{
  return Test_7::cref_type(my_storage_.of_group.content_, instruction());
}

inline Test_7::mref_type
Test_7::ref()
{
  return Test_7::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Test_7::mref_type
Test_7::mref()
{
  return Test_7::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Test_7_cref::sequence_7_cref
Test_7_cref::get_sequence_7() const
{
  return static_cast<Test_7_cref::sequence_7_cref>((*this)[0]);
}

inline Test_7_cref::sequence_7_cref
Test_7_cref::try_get_sequence_7() const
{
  return static_cast<Test_7_cref::sequence_7_cref>((*this)[0]);
}

inline Test_7_mref::sequence_7_mref
Test_7_mref::set_sequence_7() const
{
  return static_cast<Test_7_mref::sequence_7_mref>((*this)[0]);
}

inline
Test_7_cref::sequence_7_element_cref::sequence_7_element_cref(
  const mfast::value_storage*   storage,
  Test_7_cref::sequence_7_element_cref::instruction_cptr instruction)
  : base_type(storage, instruction)
{
}

inline
Test_7_mref::sequence_7_element_mref::sequence_7_element_mref(
  mfast::allocator*               alloc,
  mfast::value_storage*         storage,
  Test_7_mref::sequence_7_element_mref::instruction_cptr instruction)
  : base_type(alloc,storage, instruction)
{
}

template <typename Visitor>
inline void Test_7_cref::sequence_7_element_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<uint32_cref, copy_operator_tag, properties_type< 0> > ((*this)[0]) );
  {
    ext_cref< group_7_cref,  group_type_tag, properties_type< 1> > ext_cref_group((*this)[1]);
    ext_cref_group.set_group_present(this->field_storage(1)->is_present());
    visitor.visit(ext_cref_group);
  }
}

template <typename Visitor>
inline void Test_7_mref::sequence_7_element_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<uint32_mref, copy_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_mref< group_7_mref, group_type_tag, properties_type< 1> > ((*this)[1]) );
}

inline mfast::uint32_cref
Test_7_cref::sequence_7_element_cref::get_field_7_3() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_cref
Test_7_cref::sequence_7_element_cref::try_get_field_7_3() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_mref
Test_7_mref::sequence_7_element_mref::set_field_7_3() const
{
  return static_cast<mfast::uint32_mref>((*this)[0]);
}


inline Test_7_cref::sequence_7_element_cref::group_7_cref
Test_7_cref::sequence_7_element_cref::get_group_7() const
{
  if ((*this)[1].absent())
    return Test_7_cref::sequence_7_element_cref::group_7_cref(nullptr, Test_7_cref::sequence_7_element_cref::group_7_cref::instruction_cptr(nullptr));
  return static_cast<Test_7_cref::sequence_7_element_cref::group_7_cref>((*this)[1]);
}


inline Test_7_cref::sequence_7_element_cref::group_7_cref
Test_7_cref::sequence_7_element_cref::try_get_group_7() const
{
  if ((*this)[1].absent())
    throw mfast::bad_optional_access();
  return static_cast<Test_7_cref::sequence_7_element_cref::group_7_cref>((*this)[1]);
}

inline Test_7_mref::sequence_7_element_mref::group_7_mref
Test_7_mref::sequence_7_element_mref::set_group_7() const
{
  this->field_storage(1)->present(true);
  return Test_7_mref::sequence_7_element_mref::group_7_mref((*this)[1]);
}

inline
void
Test_7_mref::sequence_7_element_mref::omit_group_7() const
{
  (*this)[1].omit();
}

inline
Test_7_cref::sequence_7_element_cref::group_7_cref::group_7_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Test_7_cref::sequence_7_element_cref::group_7_cref::group_7_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, group_7_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Test_7_cref::sequence_7_element_cref::group_7_cref::group_7_cref(
  const mfast::field_cref& other)
  : base_type(other)
{
}

template <typename Visitor>
inline void Test_7_cref::sequence_7_element_cref::group_7_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<uint32_cref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
}

inline
Test_7_mref::sequence_7_element_mref::group_7_mref::group_7_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Test_7_mref::sequence_7_element_mref::group_7_mref::group_7_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, group_7_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Test_7_mref::sequence_7_element_mref::group_7_mref::group_7_mref(
  const mfast::field_mref_base& other)
  : base_type(other)
{
}

template <typename Visitor>
inline void Test_7_mref::sequence_7_element_mref::group_7_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<uint32_mref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
}

inline mfast::uint32_cref
Test_7_cref::sequence_7_element_cref::group_7_cref::get_field_7_4() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_cref
Test_7_cref::sequence_7_element_cref::group_7_cref::try_get_field_7_4() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_mref
Test_7_mref::sequence_7_element_mref::group_7_mref::set_field_7_4() const
{
  return static_cast<mfast::uint32_mref>((*this)[0]);
}

inline
Test_8_cref::Test_8_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Test_8_cref::Test_8_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, Test_8_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Test_8_cref::Test_8_cref(
  const mfast::message_cref& other)
  : base_type(other)
{
}

inline
Test_8_cref::Test_8_cref(
  const mfast::field_cref& other)
  : base_type(mfast::field_cref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Test_8_cref::operator mfast::message_cref()
{
  return mfast::message_cref(this->storage(), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Test_8_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, none_operator_tag, properties_type< 0> >, ext_cref< typename sequence_8_cref::reference, sequence_element_tag,properties_type< 2> > > ((*this)[0]) );
}

inline
Test_8_mref::Test_8_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Test_8_mref::Test_8_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, Test_8_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Test_8_mref::Test_8_mref(
  const mfast::message_mref& other)
  : base_type(other)
{
}

inline
Test_8_mref::Test_8_mref(
  const mfast::field_mref_base& other)
  : base_type(other.allocator(),
              mfast::field_mref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Test_8_mref::operator mfast::message_mref()
{
  return mfast::message_mref(this->allocator(), const_cast<mfast::value_storage*>(this->storage()), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Test_8_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, none_operator_tag, properties_type< 0> >, ext_mref< typename sequence_8_mref::reference, sequence_element_tag,properties_type< 2> > > ((*this)[0]) );
}

inline
Test_8::Test_8(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
Test_8::Test_8(
  const Test_8_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

#ifdef MFAST_JSON_H
Test_8::Test_8(
  const char* json_initializer,
  int json_object_tag_mask,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
  std::stringstream strm(json_initializer);
  mfast::json::decode(strm, this->mref(), json_object_tag_mask);
}

#endif
inline Test_8::cref_type
Test_8::ref() const
{
  return Test_8::cref_type(my_storage_.of_group.content_, instruction());
}

inline Test_8::cref_type
Test_8::cref() const
{
  return Test_8::cref_type(my_storage_.of_group.content_, instruction());
}

inline Test_8::mref_type
Test_8::ref()
{
  return Test_8::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Test_8::mref_type
Test_8::mref()
{
  return Test_8::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Test_8_cref::sequence_8_cref
Test_8_cref::get_sequence_8() const
{
  return static_cast<Test_8_cref::sequence_8_cref>((*this)[0]);
}

inline Test_8_cref::sequence_8_cref
Test_8_cref::try_get_sequence_8() const
{
  return static_cast<Test_8_cref::sequence_8_cref>((*this)[0]);
}

inline Test_8_mref::sequence_8_mref
Test_8_mref::set_sequence_8() const
{
  return static_cast<Test_8_mref::sequence_8_mref>((*this)[0]);
}

inline
Test_8_cref::sequence_8_element_cref::sequence_8_element_cref(
  const mfast::value_storage*   storage,
  Test_8_cref::sequence_8_element_cref::instruction_cptr instruction)
  : base_type(storage, instruction)
{
}

inline
Test_8_mref::sequence_8_element_mref::sequence_8_element_mref(
  mfast::allocator*               alloc,
  mfast::value_storage*         storage,
  Test_8_mref::sequence_8_element_mref::instruction_cptr instruction)
  : base_type(alloc,storage, instruction)
{
}

template <typename Visitor>
inline void Test_8_cref::sequence_8_element_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<uint32_cref, copy_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_cref<decimal_cref, delta_operator_tag, properties_type< 1> > ((*this)[1]) );
}

template <typename Visitor>
inline void Test_8_mref::sequence_8_element_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<uint32_mref, copy_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_mref<decimal_mref, delta_operator_tag, properties_type< 1> > ((*this)[1]) );
}

inline mfast::uint32_cref
Test_8_cref::sequence_8_element_cref::get_field_8_2() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_cref
Test_8_cref::sequence_8_element_cref::try_get_field_8_2() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_mref
Test_8_mref::sequence_8_element_mref::set_field_8_2() const
{
  return static_cast<mfast::uint32_mref>((*this)[0]);
}

inline mfast::decimal_cref
Test_8_cref::sequence_8_element_cref::get_field_8_3() const
{
  return static_cast<mfast::decimal_cref>((*this)[1]);
}

inline mfast::decimal_cref
Test_8_cref::sequence_8_element_cref::try_get_field_8_3() const
{
  if ((*this)[1].absent())
    throw mfast::bad_optional_access();
  return static_cast<mfast::decimal_cref>((*this)[1]);
}

inline mfast::decimal_mref
Test_8_mref::sequence_8_element_mref::set_field_8_3() const
{
  return static_cast<mfast::decimal_mref>((*this)[1]);
}

inline
void
Test_8_mref::sequence_8_element_mref::omit_field_8_3() const
{
  (*this)[1].omit();
}

