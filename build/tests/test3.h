// test3.h generated by mFAST from FAST Template. 
// Do not modify this file directly. Any modifications 
// will be lost the next time this file is generated.

#pragma once

#include <mfast.h>
namespace test3
{
struct mfast_tag
{
  enum element {
    JSON_UNKNOWN = 1,
    JSON_IGNORE = 2
  };
  typedef mfast::enum_field_instruction_ex<mfast_tag> instruction_type;
  static const instruction_type* instruction();
};

class mfast_tag_cref
  : public mfast::enum_cref_ex<mfast_tag_cref, mfast_tag>
{
  public:
    typedef mfast::enum_cref_ex<mfast_tag_cref, mfast_tag> base_type;
    typedef mfast_tag::element element_type;
    typedef mfast_tag::instruction_type instruction_type;
    mfast_tag_cref(
      const mfast::value_storage* storage=nullptr,
      instruction_cptr            instruction=nullptr);

    explicit mfast_tag_cref(const field_cref& other);

    element_type value() const;

    bool is_JSON_UNKNOWN() const;
    bool is_JSON_IGNORE() const;
};

class mfast_tag_mref
  : public mfast::enum_mref_ex<mfast_tag_mref, mfast_tag_cref>
{
  public:
    typedef  mfast::enum_mref_ex<mfast_tag_mref, mfast_tag_cref> base_type;
    typedef mfast_tag::element element_type;
    mfast_tag_mref(
      mfast::allocator*     alloc=nullptr,
      mfast::value_storage* storage=nullptr,
      instruction_cptr      instruction=nullptr);
    explicit mfast_tag_mref(const mfast::field_mref_base& other);

    void as_JSON_UNKNOWN() const;
    void as_JSON_IGNORE() const;
};


class Stock_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<Stock_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Stock_cref();
    template <typename T>
    Stock_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, Stock_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    Stock_cref(const mfast::message_cref& other);

    explicit Stock_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_cref get_warehouse() const;
    mfast::uint32_cref try_get_warehouse() const;
    mfast::uint32_cref get_retail() const;
    mfast::uint32_cref try_get_retail() const;

};


typedef mfast::make_aggregate_mref<Stock_cref> Stock_mref_base;
class Stock_mref
  : public Stock_mref_base
{
  typedef Stock_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<Stock_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Stock_mref();
    template <typename T>
    Stock_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, Stock_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    Stock_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit Stock_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_warehouse() const;
    mfast::uint32_mref set_retail() const;
};

class Stock
  : private mfast::value_storage_array<2>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 0
    };
    typedef mfast::template_instruction_ex<Stock_cref> instruction_type;

    typedef mfast::make_message_cref<Stock_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<Stock_mref, instruction_type> mref_type;
    Stock(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    Stock(
      const Stock_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit Stock(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    Stock(const Stock&);
    Stock& operator = (const Stock&);
};


class Product_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<Product_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Product_cref();
    template <typename T>
    Product_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, Product_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    Product_cref(const mfast::message_cref& other);

    explicit Product_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_cref get_id() const;
    mfast::uint32_cref try_get_id() const;
    mfast::ascii_string_cref get_name() const;
    mfast::ascii_string_cref try_get_name() const;
    mfast::decimal_cref get_price() const;
    mfast::decimal_cref try_get_price() const;
    typedef mfast::make_sequence_cref<mfast::ascii_string_cref, mfast::sole_element_sequence_trait> tags_cref;
    tags_cref get_tags() const;
    tags_cref try_get_tags() const;
    typedef Stock_cref stock_cref;
    stock_cref get_stock() const;
    stock_cref try_get_stock() const;

    class resalers_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<resalers_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        resalers_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::ascii_string_cref get_name() const;
        mfast::ascii_string_cref try_get_name() const;
    };

    typedef mfast::make_sequence_cref<resalers_element_cref> resalers_cref;
    resalers_cref get_resalers() const;
    resalers_cref try_get_resalers() const;
    mfast::byte_vector_cref get_ext() const;
    mfast::byte_vector_cref try_get_ext() const;

};


typedef mfast::make_aggregate_mref<Product_cref> Product_mref_base;
class Product_mref
  : public Product_mref_base
{
  typedef Product_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<Product_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Product_mref();
    template <typename T>
    Product_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, Product_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    Product_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit Product_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_id() const;
    void omit_id() const;
    mfast::ascii_string_mref set_name() const;
    mfast::decimal_mref set_price() const;
    typedef mfast::make_sequence_mref<mfast::ascii_string_mref, mfast::sole_element_sequence_trait> tags_mref;
    tags_mref set_tags() const;
    void omit_tags() const;
    typedef Stock_mref stock_mref;
    stock_mref set_stock() const;
    void omit_stock() const;
    void link_stock(const stock_mref& ref) const;
    void unlink_stock() const;

    class resalers_element_mref
      : public mfast::make_aggregate_mref<Product_cref::resalers_element_cref>
    {
      typedef mfast::make_aggregate_mref<Product_cref::resalers_element_cref> base_type;
      public:
        resalers_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::ascii_string_mref set_name() const;
    };

    typedef mfast::make_sequence_mref<resalers_element_mref> resalers_mref;
    resalers_mref set_resalers() const;
    void omit_resalers() const;
    mfast::byte_vector_mref set_ext() const;
};

class Product
  : private mfast::value_storage_array<7>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 0
    };
    typedef mfast::template_instruction_ex<Product_cref> instruction_type;

    typedef mfast::make_message_cref<Product_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<Product_mref, instruction_type> mref_type;
    Product(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    Product(
      const Product_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit Product(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    Product(const Product&);
    Product& operator = (const Product&);
};


class LoginAccount_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<LoginAccount_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    LoginAccount_cref();
    template <typename T>
    LoginAccount_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, LoginAccount_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    LoginAccount_cref(const mfast::message_cref& other);

    explicit LoginAccount_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_userName() const;
    mfast::ascii_string_cref try_get_userName() const;
    mfast::ascii_string_cref get_password() const;
    mfast::ascii_string_cref try_get_password() const;

};


typedef mfast::make_aggregate_mref<LoginAccount_cref> LoginAccount_mref_base;
class LoginAccount_mref
  : public LoginAccount_mref_base
{
  typedef LoginAccount_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<LoginAccount_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    LoginAccount_mref();
    template <typename T>
    LoginAccount_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, LoginAccount_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    LoginAccount_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit LoginAccount_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_mref set_userName() const;
    mfast::ascii_string_mref set_password() const;
    void omit_password() const;
};

class LoginAccount
  : private mfast::value_storage_array<2>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 0
    };
    typedef mfast::template_instruction_ex<LoginAccount_cref> instruction_type;

    typedef mfast::make_message_cref<LoginAccount_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<LoginAccount_mref, instruction_type> mref_type;
    LoginAccount(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    LoginAccount(
      const LoginAccount_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit LoginAccount(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    LoginAccount(const LoginAccount&);
    LoginAccount& operator = (const LoginAccount&);
};


class BankAccount_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<BankAccount_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    BankAccount_cref();
    template <typename T>
    BankAccount_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, BankAccount_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    BankAccount_cref(const mfast::message_cref& other);

    explicit BankAccount_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint64_cref get_number() const;
    mfast::uint64_cref try_get_number() const;
    mfast::uint64_cref get_routingNumber() const;
    mfast::uint64_cref try_get_routingNumber() const;
    mfast::ascii_string_cref get_bank() const;
    mfast::ascii_string_cref try_get_bank() const;
    mfast::ascii_string_cref get_alias() const;
    mfast::ascii_string_cref try_get_alias() const;

};


typedef mfast::make_aggregate_mref<BankAccount_cref> BankAccount_mref_base;
class BankAccount_mref
  : public BankAccount_mref_base
{
  typedef BankAccount_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<BankAccount_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    BankAccount_mref();
    template <typename T>
    BankAccount_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, BankAccount_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    BankAccount_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit BankAccount_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint64_mref set_number() const;
    mfast::uint64_mref set_routingNumber() const;
    mfast::ascii_string_mref set_bank() const;
    void omit_bank() const;
    mfast::ascii_string_mref set_alias() const;
    void omit_alias() const;
};

class BankAccount
  : private mfast::value_storage_array<4>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 0
    };
    typedef mfast::template_instruction_ex<BankAccount_cref> instruction_type;

    typedef mfast::make_message_cref<BankAccount_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<BankAccount_mref, instruction_type> mref_type;
    BankAccount(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    BankAccount(
      const BankAccount_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit BankAccount(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    BankAccount(const BankAccount&);
    BankAccount& operator = (const BankAccount&);
};


class Person_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<Person_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Person_cref();
    template <typename T>
    Person_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, Person_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    Person_cref(const mfast::message_cref& other);

    explicit Person_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_firstName() const;
    mfast::ascii_string_cref try_get_firstName() const;
    mfast::ascii_string_cref get_lastName() const;
    mfast::ascii_string_cref try_get_lastName() const;
    mfast::uint32_cref get_age() const;
    mfast::uint32_cref try_get_age() const;

    class address_cref
      : public mfast::aggregate_cref
    {
      typedef mfast::aggregate_cref base_type;
      public:
        typedef mfast::group_instruction_ex<address_cref> instruction_type;

        typedef const instruction_type* instruction_cptr;
        address_cref();
        template <typename T>
        address_cref(
          typename std::enable_if<std::is_same<typename T::cref_type, address_cref>::value, const mfast::value_storage*>::type storage,
          const T* instruction);

        explicit address_cref(const mfast::field_cref& other);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::ascii_string_cref get_streeAddress() const;
        mfast::ascii_string_cref try_get_streeAddress() const;
        mfast::ascii_string_cref get_city() const;
        mfast::ascii_string_cref try_get_city() const;
        mfast::ascii_string_cref get_state() const;
        mfast::ascii_string_cref try_get_state() const;
        mfast::uint32_cref get_postalCode() const;
        mfast::uint32_cref try_get_postalCode() const;
    };

    address_cref get_address() const;
    address_cref try_get_address() const;

    class phoneNumbers_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<phoneNumbers_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        phoneNumbers_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::ascii_string_cref get_type() const;
        mfast::ascii_string_cref try_get_type() const;
        mfast::ascii_string_cref get_number() const;
        mfast::ascii_string_cref try_get_number() const;
    };

    typedef mfast::make_sequence_cref<phoneNumbers_element_cref> phoneNumbers_cref;
    phoneNumbers_cref get_phoneNumbers() const;
    phoneNumbers_cref try_get_phoneNumbers() const;
    typedef mfast::make_sequence_cref<mfast::ascii_string_cref, mfast::sole_element_sequence_trait> emails_cref;
    emails_cref get_emails() const;
    emails_cref try_get_emails() const;
    typedef mfast::nested_message_cref login_cref;
    login_cref get_login() const;
    login_cref try_get_login() const;
    typedef mfast::make_sequence_cref<mfast::nested_message_cref, mfast::sole_element_sequence_trait> bankAccounts_cref;
    bankAccounts_cref get_bankAccounts() const;
    bankAccounts_cref try_get_bankAccounts() const;

};


typedef mfast::make_aggregate_mref<Person_cref> Person_mref_base;
class Person_mref
  : public Person_mref_base
{
  typedef Person_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<Person_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Person_mref();
    template <typename T>
    Person_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, Person_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    Person_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit Person_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_mref set_firstName() const;
    mfast::ascii_string_mref set_lastName() const;
    mfast::uint32_mref set_age() const;

    class address_mref
      : public mfast::make_aggregate_mref<Person_cref::address_cref>
    {
      typedef mfast::make_aggregate_mref<Person_cref::address_cref> base_type;
      public:
        address_mref();
        template <typename T>
        address_mref(
          mfast::allocator*       alloc,
          typename std::enable_if<std::is_same<typename T::cref_type, address_cref>::value, mfast::value_storage*>::type   storage,
          const T* instruction);

        explicit address_mref(const mfast::field_mref_base& other);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::ascii_string_mref set_streeAddress() const;
        mfast::ascii_string_mref set_city() const;
        mfast::ascii_string_mref set_state() const;
        mfast::uint32_mref set_postalCode() const;
    };

    address_mref set_address() const;
    void omit_address() const;

    class phoneNumbers_element_mref
      : public mfast::make_aggregate_mref<Person_cref::phoneNumbers_element_cref>
    {
      typedef mfast::make_aggregate_mref<Person_cref::phoneNumbers_element_cref> base_type;
      public:
        phoneNumbers_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::ascii_string_mref set_type() const;
        mfast::ascii_string_mref set_number() const;
    };

    typedef mfast::make_sequence_mref<phoneNumbers_element_mref> phoneNumbers_mref;
    phoneNumbers_mref set_phoneNumbers() const;
    typedef mfast::make_sequence_mref<mfast::ascii_string_mref, mfast::sole_element_sequence_trait> emails_mref;
    emails_mref set_emails() const;
    typedef mfast::nested_message_mref login_mref;
    login_mref set_login() const;
    void omit_login() const;
    void link_login(const login_mref& ref) const;
    void unlink_login() const;
    typedef mfast::make_sequence_mref<mfast::nested_message_mref, mfast::sole_element_sequence_trait> bankAccounts_mref;
    bankAccounts_mref set_bankAccounts() const;
    void omit_bankAccounts() const;
};

class Person
  : private mfast::value_storage_array<8>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 0
    };
    typedef mfast::template_instruction_ex<Person_cref> instruction_type;

    typedef mfast::make_message_cref<Person_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<Person_mref, instruction_type> mref_type;
    Person(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    Person(
      const Person_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit Person(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    Person(const Person&);
    Person& operator = (const Person&);
};


class SeqTemplate1_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<SeqTemplate1_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    SeqTemplate1_cref();
    template <typename T>
    SeqTemplate1_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, SeqTemplate1_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    SeqTemplate1_cref(const mfast::message_cref& other);

    explicit SeqTemplate1_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);


    class seq1_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<seq1_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        seq1_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::int32_cref get_field1() const;
        mfast::int32_cref try_get_field1() const;
        mfast::int32_cref get_field2() const;
        mfast::int32_cref try_get_field2() const;
    };

    typedef mfast::make_sequence_cref<seq1_element_cref> seq1_cref;
    seq1_cref get_seq1() const;
    seq1_cref try_get_seq1() const;

};


typedef mfast::make_aggregate_mref<SeqTemplate1_cref> SeqTemplate1_mref_base;
class SeqTemplate1_mref
  : public SeqTemplate1_mref_base
{
  typedef SeqTemplate1_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<SeqTemplate1_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    SeqTemplate1_mref();
    template <typename T>
    SeqTemplate1_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, SeqTemplate1_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    SeqTemplate1_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit SeqTemplate1_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);


    class seq1_element_mref
      : public mfast::make_aggregate_mref<SeqTemplate1_cref::seq1_element_cref>
    {
      typedef mfast::make_aggregate_mref<SeqTemplate1_cref::seq1_element_cref> base_type;
      public:
        seq1_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::int32_mref set_field1() const;
        mfast::int32_mref set_field2() const;
    };

    typedef mfast::make_sequence_mref<seq1_element_mref> seq1_mref;
    seq1_mref set_seq1() const;
};

class SeqTemplate1
  : private mfast::value_storage_array<1>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 0
    };
    typedef mfast::template_instruction_ex<SeqTemplate1_cref> instruction_type;

    typedef mfast::make_message_cref<SeqTemplate1_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<SeqTemplate1_mref, instruction_type> mref_type;
    SeqTemplate1(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    SeqTemplate1(
      const SeqTemplate1_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit SeqTemplate1(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    SeqTemplate1(const SeqTemplate1&);
    SeqTemplate1& operator = (const SeqTemplate1&);
};


class SeqTemplate2_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<SeqTemplate2_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    SeqTemplate2_cref();
    template <typename T>
    SeqTemplate2_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, SeqTemplate2_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    SeqTemplate2_cref(const mfast::message_cref& other);

    explicit SeqTemplate2_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    typedef mfast::make_sequence_cref<BankAccount_cref, mfast::defined_element_sequence_trait> seq2_cref;
    seq2_cref get_seq2() const;
    seq2_cref try_get_seq2() const;

};


typedef mfast::make_aggregate_mref<SeqTemplate2_cref> SeqTemplate2_mref_base;
class SeqTemplate2_mref
  : public SeqTemplate2_mref_base
{
  typedef SeqTemplate2_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<SeqTemplate2_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    SeqTemplate2_mref();
    template <typename T>
    SeqTemplate2_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, SeqTemplate2_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    SeqTemplate2_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit SeqTemplate2_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    typedef mfast::make_sequence_mref<BankAccount_mref, mfast::defined_element_sequence_trait> seq2_mref;
    seq2_mref set_seq2() const;
};

class SeqTemplate2
  : private mfast::value_storage_array<1>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 0
    };
    typedef mfast::template_instruction_ex<SeqTemplate2_cref> instruction_type;

    typedef mfast::make_message_cref<SeqTemplate2_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<SeqTemplate2_mref, instruction_type> mref_type;
    SeqTemplate2(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    SeqTemplate2(
      const SeqTemplate2_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit SeqTemplate2(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    SeqTemplate2(const SeqTemplate2&);
    SeqTemplate2& operator = (const SeqTemplate2&);
};


class UsingSeqTemplates_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<UsingSeqTemplates_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    UsingSeqTemplates_cref();
    template <typename T>
    UsingSeqTemplates_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, UsingSeqTemplates_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    UsingSeqTemplates_cref(const mfast::message_cref& other);

    explicit UsingSeqTemplates_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_string_field() const;
    mfast::ascii_string_cref try_get_string_field() const;
    typedef SeqTemplate1_cref::seq1_cref seq1_cref;
    seq1_cref get_seq1() const;
    seq1_cref try_get_seq1() const;
    typedef SeqTemplate2_cref::seq2_cref seq2_cref;
    seq2_cref get_seq2() const;
    seq2_cref try_get_seq2() const;

};


typedef mfast::make_aggregate_mref<UsingSeqTemplates_cref> UsingSeqTemplates_mref_base;
class UsingSeqTemplates_mref
  : public UsingSeqTemplates_mref_base
{
  typedef UsingSeqTemplates_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<UsingSeqTemplates_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    UsingSeqTemplates_mref();
    template <typename T>
    UsingSeqTemplates_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, UsingSeqTemplates_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    UsingSeqTemplates_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit UsingSeqTemplates_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_mref set_string_field() const;
    typedef SeqTemplate1_mref::seq1_mref seq1_mref;
    seq1_mref set_seq1() const;
    typedef SeqTemplate2_mref::seq2_mref seq2_mref;
    seq2_mref set_seq2() const;
};

class UsingSeqTemplates
  : private mfast::value_storage_array<3>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 0
    };
    typedef mfast::template_instruction_ex<UsingSeqTemplates_cref> instruction_type;

    typedef mfast::make_message_cref<UsingSeqTemplates_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<UsingSeqTemplates_mref, instruction_type> mref_type;
    UsingSeqTemplates(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    UsingSeqTemplates(
      const UsingSeqTemplates_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit UsingSeqTemplates(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    UsingSeqTemplates(const UsingSeqTemplates&);
    UsingSeqTemplates& operator = (const UsingSeqTemplates&);
};


struct  templates_description
  : mfast::templates_description
{
  typedef std::tuple<> types;
  templates_description();
  static const templates_description* instance();
};

inline const templates_description* description()
{
  return templates_description::instance();
}

#include "test3.inl"
}
