// scp.h generated by mFAST from FAST Template. 
// Do not modify this file directly. Any modifications 
// will be lost the next time this file is generated.

#pragma once

#include <mfast.h>
namespace scp
{

class Reset_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<Reset_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Reset_cref();
    template <typename T>
    Reset_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, Reset_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    Reset_cref(const mfast::message_cref& other);

    explicit Reset_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);


};


typedef mfast::make_aggregate_mref<Reset_cref> Reset_mref_base;
class Reset_mref
  : public Reset_mref_base
{
  typedef Reset_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<Reset_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Reset_mref();
    template <typename T>
    Reset_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, Reset_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    Reset_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit Reset_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

};

class Reset
  : private mfast::value_storage_array<0>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 120
    };
    typedef mfast::template_instruction_ex<Reset_cref> instruction_type;

    typedef mfast::make_message_cref<Reset_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<Reset_mref, instruction_type> mref_type;
    Reset(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    Reset(
      const Reset_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit Reset(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    Reset(const Reset&);
    Reset& operator = (const Reset&);
};


struct  templates_description
  : mfast::templates_description
{
  typedef std::tuple<Reset> types;
  templates_description();
  static const templates_description* instance();
};

inline const templates_description* description()
{
  return templates_description::instance();
}

#include "scp.inl"
}
