// test3.inl generated by mFAST from FAST Template. 
// Do not modify this file directly. Any modifications 
// will be lost the next time this file is generated.

inline
mfast_tag_cref::mfast_tag_cref(
  const mfast::value_storage*   storage,
  mfast_tag_cref::instruction_cptr instruction)
  : base_type(storage, instruction)
{
}

inline
mfast_tag_cref::mfast_tag_cref(
  const mfast::field_cref& other)
  : base_type(other)
{
}

inline
mfast_tag_mref::mfast_tag_mref(
  mfast::allocator*      alloc,
  mfast::value_storage*  storage,
  mfast_tag_mref::instruction_cptr instruction)
  : base_type(alloc, storage, instruction)
{
}

inline
mfast_tag_mref::mfast_tag_mref(
  const mfast::field_mref_base& other)
  : base_type(other)
{
}

inline
mfast_tag_cref::element_type
mfast_tag_cref::value() const
{
  return static_cast<mfast_tag::element>(base_type::value());
}

inline
bool mfast_tag_cref::is_JSON_UNKNOWN() const
{
  return this->value() == mfast_tag::JSON_UNKNOWN;
}

inline
void mfast_tag_mref::as_JSON_UNKNOWN() const
{
  return this->as(mfast_tag::JSON_UNKNOWN);
}

inline
bool mfast_tag_cref::is_JSON_IGNORE() const
{
  return this->value() == mfast_tag::JSON_IGNORE;
}

inline
void mfast_tag_mref::as_JSON_IGNORE() const
{
  return this->as(mfast_tag::JSON_IGNORE);
}

inline
Stock_cref::Stock_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Stock_cref::Stock_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, Stock_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Stock_cref::Stock_cref(
  const mfast::message_cref& other)
  : base_type(other)
{
}

inline
Stock_cref::Stock_cref(
  const mfast::field_cref& other)
  : base_type(mfast::field_cref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Stock_cref::operator mfast::message_cref()
{
  return mfast::message_cref(this->storage(), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Stock_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<uint32_cref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_cref<uint32_cref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
}

inline
Stock_mref::Stock_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Stock_mref::Stock_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, Stock_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Stock_mref::Stock_mref(
  const mfast::message_mref& other)
  : base_type(other)
{
}

inline
Stock_mref::Stock_mref(
  const mfast::field_mref_base& other)
  : base_type(other.allocator(),
              mfast::field_mref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Stock_mref::operator mfast::message_mref()
{
  return mfast::message_mref(this->allocator(), const_cast<mfast::value_storage*>(this->storage()), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Stock_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<uint32_mref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_mref<uint32_mref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
}

inline
Stock::Stock(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
Stock::Stock(
  const Stock_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

#ifdef MFAST_JSON_H
Stock::Stock(
  const char* json_initializer,
  int json_object_tag_mask,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
  std::stringstream strm(json_initializer);
  mfast::json::decode(strm, this->mref(), json_object_tag_mask);
}

#endif
inline Stock::cref_type
Stock::ref() const
{
  return Stock::cref_type(my_storage_.of_group.content_, instruction());
}

inline Stock::cref_type
Stock::cref() const
{
  return Stock::cref_type(my_storage_.of_group.content_, instruction());
}

inline Stock::mref_type
Stock::ref()
{
  return Stock::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Stock::mref_type
Stock::mref()
{
  return Stock::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline mfast::uint32_cref
Stock_cref::get_warehouse() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_cref
Stock_cref::try_get_warehouse() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_mref
Stock_mref::set_warehouse() const
{
  return static_cast<mfast::uint32_mref>((*this)[0]);
}

inline mfast::uint32_cref
Stock_cref::get_retail() const
{
  return static_cast<mfast::uint32_cref>((*this)[1]);
}

inline mfast::uint32_cref
Stock_cref::try_get_retail() const
{
  return static_cast<mfast::uint32_cref>((*this)[1]);
}

inline mfast::uint32_mref
Stock_mref::set_retail() const
{
  return static_cast<mfast::uint32_mref>((*this)[1]);
}

inline
Product_cref::Product_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Product_cref::Product_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, Product_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Product_cref::Product_cref(
  const mfast::message_cref& other)
  : base_type(other)
{
}

inline
Product_cref::Product_cref(
  const mfast::field_cref& other)
  : base_type(mfast::field_cref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Product_cref::operator mfast::message_cref()
{
  return mfast::message_cref(this->storage(), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Product_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<uint32_cref, none_operator_tag, properties_type< 1> > ((*this)[0]) );
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
  visitor.visit(ext_cref<decimal_cref, delta_operator_tag, properties_type< 0> > ((*this)[2]) );
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, none_operator_tag, properties_type< 1> >, ext_cref< typename tags_cref::reference, none_operator_tag, properties_type< 0>  > > ((*this)[3]) );
  {
    ext_cref< stock_cref,  group_type_tag, properties_type< 1> > ext_cref_group((*this)[4]);
    ext_cref_group.set_group_present(this->field_storage(4)->is_present());
    visitor.visit(ext_cref_group);
  }
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, none_operator_tag, properties_type< 1> >, ext_cref< typename resalers_cref::reference, sequence_element_tag,properties_type< 0> > > ((*this)[5]) );
  visitor.visit(ext_cref<byte_vector_cref, none_operator_tag, properties_type< 0> > ((*this)[6]) );
}

inline
Product_mref::Product_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Product_mref::Product_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, Product_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Product_mref::Product_mref(
  const mfast::message_mref& other)
  : base_type(other)
{
}

inline
Product_mref::Product_mref(
  const mfast::field_mref_base& other)
  : base_type(other.allocator(),
              mfast::field_mref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Product_mref::operator mfast::message_mref()
{
  return mfast::message_mref(this->allocator(), const_cast<mfast::value_storage*>(this->storage()), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Product_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<uint32_mref, none_operator_tag, properties_type< 1> > ((*this)[0]) );
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
  visitor.visit(ext_mref<decimal_mref, delta_operator_tag, properties_type< 0> > ((*this)[2]) );
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, none_operator_tag, properties_type< 1> >, ext_mref< typename tags_mref::reference, none_operator_tag, properties_type< 0>  > > ((*this)[3]) );
  visitor.visit(ext_mref< stock_mref, group_type_tag, properties_type< 1> > ((*this)[4]) );
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, none_operator_tag, properties_type< 1> >, ext_mref< typename resalers_mref::reference, sequence_element_tag,properties_type< 0> > > ((*this)[5]) );
  visitor.visit(ext_mref<byte_vector_mref, none_operator_tag, properties_type< 0> > ((*this)[6]) );
}

inline
Product::Product(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
Product::Product(
  const Product_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

#ifdef MFAST_JSON_H
Product::Product(
  const char* json_initializer,
  int json_object_tag_mask,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
  std::stringstream strm(json_initializer);
  mfast::json::decode(strm, this->mref(), json_object_tag_mask);
}

#endif
inline Product::cref_type
Product::ref() const
{
  return Product::cref_type(my_storage_.of_group.content_, instruction());
}

inline Product::cref_type
Product::cref() const
{
  return Product::cref_type(my_storage_.of_group.content_, instruction());
}

inline Product::mref_type
Product::ref()
{
  return Product::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Product::mref_type
Product::mref()
{
  return Product::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline mfast::uint32_cref
Product_cref::get_id() const
{
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_cref
Product_cref::try_get_id() const
{
  if ((*this)[0].absent())
    throw mfast::bad_optional_access();
  return static_cast<mfast::uint32_cref>((*this)[0]);
}

inline mfast::uint32_mref
Product_mref::set_id() const
{
  return static_cast<mfast::uint32_mref>((*this)[0]);
}

inline
void
Product_mref::omit_id() const
{
  (*this)[0].omit();
}

inline mfast::ascii_string_cref
Product_cref::get_name() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[1]);
}

inline mfast::ascii_string_cref
Product_cref::try_get_name() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[1]);
}

inline mfast::ascii_string_mref
Product_mref::set_name() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[1]);
}

inline mfast::decimal_cref
Product_cref::get_price() const
{
  return static_cast<mfast::decimal_cref>((*this)[2]);
}

inline mfast::decimal_cref
Product_cref::try_get_price() const
{
  return static_cast<mfast::decimal_cref>((*this)[2]);
}

inline mfast::decimal_mref
Product_mref::set_price() const
{
  return static_cast<mfast::decimal_mref>((*this)[2]);
}

inline Product_cref::tags_cref
Product_cref::get_tags() const
{
  return static_cast<Product_cref::tags_cref>((*this)[3]);
}

inline Product_cref::tags_cref
Product_cref::try_get_tags() const
{
  if ((*this)[3].absent())
    throw mfast::bad_optional_access();
  return static_cast<Product_cref::tags_cref>((*this)[3]);
}

inline Product_mref::tags_mref
Product_mref::set_tags() const
{
  return static_cast<Product_mref::tags_mref>((*this)[3]);
}

inline
void
Product_mref::omit_tags() const
{
  (*this)[3].omit();
}


inline Product_cref::stock_cref
Product_cref::get_stock() const
{
  if ((*this)[4].absent())
    return Product_cref::stock_cref(nullptr, Product_cref::stock_cref::instruction_cptr(nullptr));
  return static_cast<Product_cref::stock_cref>((*this)[4]);
}


inline Product_cref::stock_cref
Product_cref::try_get_stock() const
{
  if ((*this)[4].absent())
    throw mfast::bad_optional_access();
  return static_cast<Product_cref::stock_cref>((*this)[4]);
}

inline Product_mref::stock_mref
Product_mref::set_stock() const
{
  this->field_storage(4)->present(true);
  return Product_mref::stock_mref((*this)[4]);
}

inline
void
Product_mref::omit_stock() const
{
  (*this)[4].omit();
}

inline void
Product_mref::link_stock(const Product_mref::stock_mref& ref) const
{
  this->link_group_at(4, ref);
}

inline void
Product_mref::unlink_stock() const
{
  this->unlink_group_at(4);
}

inline Product_cref::resalers_cref
Product_cref::get_resalers() const
{
  return static_cast<Product_cref::resalers_cref>((*this)[5]);
}

inline Product_cref::resalers_cref
Product_cref::try_get_resalers() const
{
  if ((*this)[5].absent())
    throw mfast::bad_optional_access();
  return static_cast<Product_cref::resalers_cref>((*this)[5]);
}

inline Product_mref::resalers_mref
Product_mref::set_resalers() const
{
  return static_cast<Product_mref::resalers_mref>((*this)[5]);
}

inline
void
Product_mref::omit_resalers() const
{
  (*this)[5].omit();
}

inline
Product_cref::resalers_element_cref::resalers_element_cref(
  const mfast::value_storage*   storage,
  Product_cref::resalers_element_cref::instruction_cptr instruction)
  : base_type(storage, instruction)
{
}

inline
Product_mref::resalers_element_mref::resalers_element_mref(
  mfast::allocator*               alloc,
  mfast::value_storage*         storage,
  Product_mref::resalers_element_mref::instruction_cptr instruction)
  : base_type(alloc,storage, instruction)
{
}

template <typename Visitor>
inline void Product_cref::resalers_element_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
}

template <typename Visitor>
inline void Product_mref::resalers_element_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
}

inline mfast::ascii_string_cref
Product_cref::resalers_element_cref::get_name() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_cref
Product_cref::resalers_element_cref::try_get_name() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_mref
Product_mref::resalers_element_mref::set_name() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[0]);
}

inline mfast::byte_vector_cref
Product_cref::get_ext() const
{
  return static_cast<mfast::byte_vector_cref>((*this)[6]);
}

inline mfast::byte_vector_cref
Product_cref::try_get_ext() const
{
  return static_cast<mfast::byte_vector_cref>((*this)[6]);
}

inline mfast::byte_vector_mref
Product_mref::set_ext() const
{
  return static_cast<mfast::byte_vector_mref>((*this)[6]);
}

inline
LoginAccount_cref::LoginAccount_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
LoginAccount_cref::LoginAccount_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, LoginAccount_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
LoginAccount_cref::LoginAccount_cref(
  const mfast::message_cref& other)
  : base_type(other)
{
}

inline
LoginAccount_cref::LoginAccount_cref(
  const mfast::field_cref& other)
  : base_type(mfast::field_cref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
LoginAccount_cref::operator mfast::message_cref()
{
  return mfast::message_cref(this->storage(), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void LoginAccount_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 1> > ((*this)[1]) );
}

inline
LoginAccount_mref::LoginAccount_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
LoginAccount_mref::LoginAccount_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, LoginAccount_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
LoginAccount_mref::LoginAccount_mref(
  const mfast::message_mref& other)
  : base_type(other)
{
}

inline
LoginAccount_mref::LoginAccount_mref(
  const mfast::field_mref_base& other)
  : base_type(other.allocator(),
              mfast::field_mref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
LoginAccount_mref::operator mfast::message_mref()
{
  return mfast::message_mref(this->allocator(), const_cast<mfast::value_storage*>(this->storage()), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void LoginAccount_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 1> > ((*this)[1]) );
}

inline
LoginAccount::LoginAccount(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
LoginAccount::LoginAccount(
  const LoginAccount_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

#ifdef MFAST_JSON_H
LoginAccount::LoginAccount(
  const char* json_initializer,
  int json_object_tag_mask,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
  std::stringstream strm(json_initializer);
  mfast::json::decode(strm, this->mref(), json_object_tag_mask);
}

#endif
inline LoginAccount::cref_type
LoginAccount::ref() const
{
  return LoginAccount::cref_type(my_storage_.of_group.content_, instruction());
}

inline LoginAccount::cref_type
LoginAccount::cref() const
{
  return LoginAccount::cref_type(my_storage_.of_group.content_, instruction());
}

inline LoginAccount::mref_type
LoginAccount::ref()
{
  return LoginAccount::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline LoginAccount::mref_type
LoginAccount::mref()
{
  return LoginAccount::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline mfast::ascii_string_cref
LoginAccount_cref::get_userName() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_cref
LoginAccount_cref::try_get_userName() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_mref
LoginAccount_mref::set_userName() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[0]);
}

inline mfast::ascii_string_cref
LoginAccount_cref::get_password() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[1]);
}

inline mfast::ascii_string_cref
LoginAccount_cref::try_get_password() const
{
  if ((*this)[1].absent())
    throw mfast::bad_optional_access();
  return static_cast<mfast::ascii_string_cref>((*this)[1]);
}

inline mfast::ascii_string_mref
LoginAccount_mref::set_password() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[1]);
}

inline
void
LoginAccount_mref::omit_password() const
{
  (*this)[1].omit();
}

inline
BankAccount_cref::BankAccount_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
BankAccount_cref::BankAccount_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, BankAccount_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
BankAccount_cref::BankAccount_cref(
  const mfast::message_cref& other)
  : base_type(other)
{
}

inline
BankAccount_cref::BankAccount_cref(
  const mfast::field_cref& other)
  : base_type(mfast::field_cref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
BankAccount_cref::operator mfast::message_cref()
{
  return mfast::message_cref(this->storage(), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void BankAccount_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<uint64_cref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_cref<uint64_cref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 1> > ((*this)[2]) );
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 1> > ((*this)[3]) );
}

inline
BankAccount_mref::BankAccount_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
BankAccount_mref::BankAccount_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, BankAccount_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
BankAccount_mref::BankAccount_mref(
  const mfast::message_mref& other)
  : base_type(other)
{
}

inline
BankAccount_mref::BankAccount_mref(
  const mfast::field_mref_base& other)
  : base_type(other.allocator(),
              mfast::field_mref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
BankAccount_mref::operator mfast::message_mref()
{
  return mfast::message_mref(this->allocator(), const_cast<mfast::value_storage*>(this->storage()), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void BankAccount_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<uint64_mref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_mref<uint64_mref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 1> > ((*this)[2]) );
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 1> > ((*this)[3]) );
}

inline
BankAccount::BankAccount(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
BankAccount::BankAccount(
  const BankAccount_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

#ifdef MFAST_JSON_H
BankAccount::BankAccount(
  const char* json_initializer,
  int json_object_tag_mask,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
  std::stringstream strm(json_initializer);
  mfast::json::decode(strm, this->mref(), json_object_tag_mask);
}

#endif
inline BankAccount::cref_type
BankAccount::ref() const
{
  return BankAccount::cref_type(my_storage_.of_group.content_, instruction());
}

inline BankAccount::cref_type
BankAccount::cref() const
{
  return BankAccount::cref_type(my_storage_.of_group.content_, instruction());
}

inline BankAccount::mref_type
BankAccount::ref()
{
  return BankAccount::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline BankAccount::mref_type
BankAccount::mref()
{
  return BankAccount::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline mfast::uint64_cref
BankAccount_cref::get_number() const
{
  return static_cast<mfast::uint64_cref>((*this)[0]);
}

inline mfast::uint64_cref
BankAccount_cref::try_get_number() const
{
  return static_cast<mfast::uint64_cref>((*this)[0]);
}

inline mfast::uint64_mref
BankAccount_mref::set_number() const
{
  return static_cast<mfast::uint64_mref>((*this)[0]);
}

inline mfast::uint64_cref
BankAccount_cref::get_routingNumber() const
{
  return static_cast<mfast::uint64_cref>((*this)[1]);
}

inline mfast::uint64_cref
BankAccount_cref::try_get_routingNumber() const
{
  return static_cast<mfast::uint64_cref>((*this)[1]);
}

inline mfast::uint64_mref
BankAccount_mref::set_routingNumber() const
{
  return static_cast<mfast::uint64_mref>((*this)[1]);
}

inline mfast::ascii_string_cref
BankAccount_cref::get_bank() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[2]);
}

inline mfast::ascii_string_cref
BankAccount_cref::try_get_bank() const
{
  if ((*this)[2].absent())
    throw mfast::bad_optional_access();
  return static_cast<mfast::ascii_string_cref>((*this)[2]);
}

inline mfast::ascii_string_mref
BankAccount_mref::set_bank() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[2]);
}

inline
void
BankAccount_mref::omit_bank() const
{
  (*this)[2].omit();
}

inline mfast::ascii_string_cref
BankAccount_cref::get_alias() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[3]);
}

inline mfast::ascii_string_cref
BankAccount_cref::try_get_alias() const
{
  if ((*this)[3].absent())
    throw mfast::bad_optional_access();
  return static_cast<mfast::ascii_string_cref>((*this)[3]);
}

inline mfast::ascii_string_mref
BankAccount_mref::set_alias() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[3]);
}

inline
void
BankAccount_mref::omit_alias() const
{
  (*this)[3].omit();
}

inline
Person_cref::Person_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Person_cref::Person_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, Person_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Person_cref::Person_cref(
  const mfast::message_cref& other)
  : base_type(other)
{
}

inline
Person_cref::Person_cref(
  const mfast::field_cref& other)
  : base_type(mfast::field_cref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Person_cref::operator mfast::message_cref()
{
  return mfast::message_cref(this->storage(), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Person_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
  visitor.visit(ext_cref<uint32_cref, none_operator_tag, properties_type< 0> > ((*this)[2]) );
  {
    ext_cref< address_cref,  group_type_tag, properties_type< 1> > ext_cref_group((*this)[3]);
    ext_cref_group.set_group_present(this->field_storage(3)->is_present());
    visitor.visit(ext_cref_group);
  }
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, none_operator_tag, properties_type< 0> >, ext_cref< typename phoneNumbers_cref::reference, sequence_element_tag,properties_type< 0> > > ((*this)[4]) );
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, none_operator_tag, properties_type< 0> >, ext_cref< typename emails_cref::reference, none_operator_tag, properties_type< 0>  > > ((*this)[5]) );
  {
    ext_cref< login_cref,  group_type_tag, properties_type< 1> > ext_cref_group((*this)[6]);
    ext_cref_group.set_group_present(this->field_storage(6)->is_present());
    visitor.visit(ext_cref_group);
  }
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, none_operator_tag, properties_type< 1> >, ext_cref< typename bankAccounts_cref::reference, none_operator_tag, properties_type< 0>  > > ((*this)[7]) );
}

inline
Person_mref::Person_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Person_mref::Person_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, Person_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Person_mref::Person_mref(
  const mfast::message_mref& other)
  : base_type(other)
{
}

inline
Person_mref::Person_mref(
  const mfast::field_mref_base& other)
  : base_type(other.allocator(),
              mfast::field_mref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
Person_mref::operator mfast::message_mref()
{
  return mfast::message_mref(this->allocator(), const_cast<mfast::value_storage*>(this->storage()), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void Person_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
  visitor.visit(ext_mref<uint32_mref, none_operator_tag, properties_type< 0> > ((*this)[2]) );
  visitor.visit(ext_mref< address_mref, group_type_tag, properties_type< 1> > ((*this)[3]) );
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, none_operator_tag, properties_type< 0> >, ext_mref< typename phoneNumbers_mref::reference, sequence_element_tag,properties_type< 0> > > ((*this)[4]) );
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, none_operator_tag, properties_type< 0> >, ext_mref< typename emails_mref::reference, none_operator_tag, properties_type< 0>  > > ((*this)[5]) );
  visitor.visit(ext_mref< login_mref, group_type_tag, properties_type< 1> > ((*this)[6]) );
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, none_operator_tag, properties_type< 1> >, ext_mref< typename bankAccounts_mref::reference, none_operator_tag, properties_type< 0>  > > ((*this)[7]) );
}

inline
Person::Person(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
Person::Person(
  const Person_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

#ifdef MFAST_JSON_H
Person::Person(
  const char* json_initializer,
  int json_object_tag_mask,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
  std::stringstream strm(json_initializer);
  mfast::json::decode(strm, this->mref(), json_object_tag_mask);
}

#endif
inline Person::cref_type
Person::ref() const
{
  return Person::cref_type(my_storage_.of_group.content_, instruction());
}

inline Person::cref_type
Person::cref() const
{
  return Person::cref_type(my_storage_.of_group.content_, instruction());
}

inline Person::mref_type
Person::ref()
{
  return Person::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline Person::mref_type
Person::mref()
{
  return Person::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline mfast::ascii_string_cref
Person_cref::get_firstName() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_cref
Person_cref::try_get_firstName() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_mref
Person_mref::set_firstName() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[0]);
}

inline mfast::ascii_string_cref
Person_cref::get_lastName() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[1]);
}

inline mfast::ascii_string_cref
Person_cref::try_get_lastName() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[1]);
}

inline mfast::ascii_string_mref
Person_mref::set_lastName() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[1]);
}

inline mfast::uint32_cref
Person_cref::get_age() const
{
  return static_cast<mfast::uint32_cref>((*this)[2]);
}

inline mfast::uint32_cref
Person_cref::try_get_age() const
{
  return static_cast<mfast::uint32_cref>((*this)[2]);
}

inline mfast::uint32_mref
Person_mref::set_age() const
{
  return static_cast<mfast::uint32_mref>((*this)[2]);
}


inline Person_cref::address_cref
Person_cref::get_address() const
{
  if ((*this)[3].absent())
    return Person_cref::address_cref(nullptr, Person_cref::address_cref::instruction_cptr(nullptr));
  return static_cast<Person_cref::address_cref>((*this)[3]);
}


inline Person_cref::address_cref
Person_cref::try_get_address() const
{
  if ((*this)[3].absent())
    throw mfast::bad_optional_access();
  return static_cast<Person_cref::address_cref>((*this)[3]);
}

inline Person_mref::address_mref
Person_mref::set_address() const
{
  this->field_storage(3)->present(true);
  return Person_mref::address_mref((*this)[3]);
}

inline
void
Person_mref::omit_address() const
{
  (*this)[3].omit();
}

inline
Person_cref::address_cref::address_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
Person_cref::address_cref::address_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, address_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
Person_cref::address_cref::address_cref(
  const mfast::field_cref& other)
  : base_type(other)
{
}

template <typename Visitor>
inline void Person_cref::address_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 0> > ((*this)[2]) );
  visitor.visit(ext_cref<uint32_cref, none_operator_tag, properties_type< 0> > ((*this)[3]) );
}

inline
Person_mref::address_mref::address_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
Person_mref::address_mref::address_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, address_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
Person_mref::address_mref::address_mref(
  const mfast::field_mref_base& other)
  : base_type(other)
{
}

template <typename Visitor>
inline void Person_mref::address_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 0> > ((*this)[2]) );
  visitor.visit(ext_mref<uint32_mref, none_operator_tag, properties_type< 0> > ((*this)[3]) );
}

inline mfast::ascii_string_cref
Person_cref::address_cref::get_streeAddress() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_cref
Person_cref::address_cref::try_get_streeAddress() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_mref
Person_mref::address_mref::set_streeAddress() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[0]);
}

inline mfast::ascii_string_cref
Person_cref::address_cref::get_city() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[1]);
}

inline mfast::ascii_string_cref
Person_cref::address_cref::try_get_city() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[1]);
}

inline mfast::ascii_string_mref
Person_mref::address_mref::set_city() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[1]);
}

inline mfast::ascii_string_cref
Person_cref::address_cref::get_state() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[2]);
}

inline mfast::ascii_string_cref
Person_cref::address_cref::try_get_state() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[2]);
}

inline mfast::ascii_string_mref
Person_mref::address_mref::set_state() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[2]);
}

inline mfast::uint32_cref
Person_cref::address_cref::get_postalCode() const
{
  return static_cast<mfast::uint32_cref>((*this)[3]);
}

inline mfast::uint32_cref
Person_cref::address_cref::try_get_postalCode() const
{
  return static_cast<mfast::uint32_cref>((*this)[3]);
}

inline mfast::uint32_mref
Person_mref::address_mref::set_postalCode() const
{
  return static_cast<mfast::uint32_mref>((*this)[3]);
}

inline Person_cref::phoneNumbers_cref
Person_cref::get_phoneNumbers() const
{
  return static_cast<Person_cref::phoneNumbers_cref>((*this)[4]);
}

inline Person_cref::phoneNumbers_cref
Person_cref::try_get_phoneNumbers() const
{
  return static_cast<Person_cref::phoneNumbers_cref>((*this)[4]);
}

inline Person_mref::phoneNumbers_mref
Person_mref::set_phoneNumbers() const
{
  return static_cast<Person_mref::phoneNumbers_mref>((*this)[4]);
}

inline
Person_cref::phoneNumbers_element_cref::phoneNumbers_element_cref(
  const mfast::value_storage*   storage,
  Person_cref::phoneNumbers_element_cref::instruction_cptr instruction)
  : base_type(storage, instruction)
{
}

inline
Person_mref::phoneNumbers_element_mref::phoneNumbers_element_mref(
  mfast::allocator*               alloc,
  mfast::value_storage*         storage,
  Person_mref::phoneNumbers_element_mref::instruction_cptr instruction)
  : base_type(alloc,storage, instruction)
{
}

template <typename Visitor>
inline void Person_cref::phoneNumbers_element_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
}

template <typename Visitor>
inline void Person_mref::phoneNumbers_element_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
}

inline mfast::ascii_string_cref
Person_cref::phoneNumbers_element_cref::get_type() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_cref
Person_cref::phoneNumbers_element_cref::try_get_type() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_mref
Person_mref::phoneNumbers_element_mref::set_type() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[0]);
}

inline mfast::ascii_string_cref
Person_cref::phoneNumbers_element_cref::get_number() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[1]);
}

inline mfast::ascii_string_cref
Person_cref::phoneNumbers_element_cref::try_get_number() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[1]);
}

inline mfast::ascii_string_mref
Person_mref::phoneNumbers_element_mref::set_number() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[1]);
}

inline Person_cref::emails_cref
Person_cref::get_emails() const
{
  return static_cast<Person_cref::emails_cref>((*this)[5]);
}

inline Person_cref::emails_cref
Person_cref::try_get_emails() const
{
  return static_cast<Person_cref::emails_cref>((*this)[5]);
}

inline Person_mref::emails_mref
Person_mref::set_emails() const
{
  return static_cast<Person_mref::emails_mref>((*this)[5]);
}


inline Person_cref::login_cref
Person_cref::get_login() const
{
  if ((*this)[6].absent())
    return Person_cref::login_cref(nullptr, Person_cref::login_cref::instruction_cptr(nullptr));
  return static_cast<Person_cref::login_cref>(mfast::aggregate_cref((*this)[6])[0]);
}


inline Person_cref::login_cref
Person_cref::try_get_login() const
{
  if ((*this)[6].absent())
    throw mfast::bad_optional_access();
  return static_cast<Person_cref::login_cref>(mfast::aggregate_cref((*this)[6])[0]);
}

inline Person_mref::login_mref
Person_mref::set_login() const
{
  this->field_storage(6)->present(true);
  return Person_mref::login_mref(mfast::aggregate_mref((*this)[6])[0]);
}

inline
void
Person_mref::omit_login() const
{
  (*this)[6].omit();
}

inline Person_cref::bankAccounts_cref
Person_cref::get_bankAccounts() const
{
  return static_cast<Person_cref::bankAccounts_cref>((*this)[7]);
}

inline Person_cref::bankAccounts_cref
Person_cref::try_get_bankAccounts() const
{
  if ((*this)[7].absent())
    throw mfast::bad_optional_access();
  return static_cast<Person_cref::bankAccounts_cref>((*this)[7]);
}

inline Person_mref::bankAccounts_mref
Person_mref::set_bankAccounts() const
{
  return static_cast<Person_mref::bankAccounts_mref>((*this)[7]);
}

inline
void
Person_mref::omit_bankAccounts() const
{
  (*this)[7].omit();
}

inline
SeqTemplate1_cref::SeqTemplate1_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
SeqTemplate1_cref::SeqTemplate1_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, SeqTemplate1_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
SeqTemplate1_cref::SeqTemplate1_cref(
  const mfast::message_cref& other)
  : base_type(other)
{
}

inline
SeqTemplate1_cref::SeqTemplate1_cref(
  const mfast::field_cref& other)
  : base_type(mfast::field_cref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
SeqTemplate1_cref::operator mfast::message_cref()
{
  return mfast::message_cref(this->storage(), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void SeqTemplate1_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, none_operator_tag, properties_type< 0> >, ext_cref< typename seq1_cref::reference, sequence_element_tag,properties_type< 0> > > ((*this)[0]) );
}

inline
SeqTemplate1_mref::SeqTemplate1_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
SeqTemplate1_mref::SeqTemplate1_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, SeqTemplate1_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
SeqTemplate1_mref::SeqTemplate1_mref(
  const mfast::message_mref& other)
  : base_type(other)
{
}

inline
SeqTemplate1_mref::SeqTemplate1_mref(
  const mfast::field_mref_base& other)
  : base_type(other.allocator(),
              mfast::field_mref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
SeqTemplate1_mref::operator mfast::message_mref()
{
  return mfast::message_mref(this->allocator(), const_cast<mfast::value_storage*>(this->storage()), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void SeqTemplate1_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, none_operator_tag, properties_type< 0> >, ext_mref< typename seq1_mref::reference, sequence_element_tag,properties_type< 0> > > ((*this)[0]) );
}

inline
SeqTemplate1::SeqTemplate1(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
SeqTemplate1::SeqTemplate1(
  const SeqTemplate1_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

#ifdef MFAST_JSON_H
SeqTemplate1::SeqTemplate1(
  const char* json_initializer,
  int json_object_tag_mask,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
  std::stringstream strm(json_initializer);
  mfast::json::decode(strm, this->mref(), json_object_tag_mask);
}

#endif
inline SeqTemplate1::cref_type
SeqTemplate1::ref() const
{
  return SeqTemplate1::cref_type(my_storage_.of_group.content_, instruction());
}

inline SeqTemplate1::cref_type
SeqTemplate1::cref() const
{
  return SeqTemplate1::cref_type(my_storage_.of_group.content_, instruction());
}

inline SeqTemplate1::mref_type
SeqTemplate1::ref()
{
  return SeqTemplate1::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline SeqTemplate1::mref_type
SeqTemplate1::mref()
{
  return SeqTemplate1::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline SeqTemplate1_cref::seq1_cref
SeqTemplate1_cref::get_seq1() const
{
  return static_cast<SeqTemplate1_cref::seq1_cref>((*this)[0]);
}

inline SeqTemplate1_cref::seq1_cref
SeqTemplate1_cref::try_get_seq1() const
{
  return static_cast<SeqTemplate1_cref::seq1_cref>((*this)[0]);
}

inline SeqTemplate1_mref::seq1_mref
SeqTemplate1_mref::set_seq1() const
{
  return static_cast<SeqTemplate1_mref::seq1_mref>((*this)[0]);
}

inline
SeqTemplate1_cref::seq1_element_cref::seq1_element_cref(
  const mfast::value_storage*   storage,
  SeqTemplate1_cref::seq1_element_cref::instruction_cptr instruction)
  : base_type(storage, instruction)
{
}

inline
SeqTemplate1_mref::seq1_element_mref::seq1_element_mref(
  mfast::allocator*               alloc,
  mfast::value_storage*         storage,
  SeqTemplate1_mref::seq1_element_mref::instruction_cptr instruction)
  : base_type(alloc,storage, instruction)
{
}

template <typename Visitor>
inline void SeqTemplate1_cref::seq1_element_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<int32_cref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_cref<int32_cref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
}

template <typename Visitor>
inline void SeqTemplate1_mref::seq1_element_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<int32_mref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_mref<int32_mref, none_operator_tag, properties_type< 0> > ((*this)[1]) );
}

inline mfast::int32_cref
SeqTemplate1_cref::seq1_element_cref::get_field1() const
{
  return static_cast<mfast::int32_cref>((*this)[0]);
}

inline mfast::int32_cref
SeqTemplate1_cref::seq1_element_cref::try_get_field1() const
{
  return static_cast<mfast::int32_cref>((*this)[0]);
}

inline mfast::int32_mref
SeqTemplate1_mref::seq1_element_mref::set_field1() const
{
  return static_cast<mfast::int32_mref>((*this)[0]);
}

inline mfast::int32_cref
SeqTemplate1_cref::seq1_element_cref::get_field2() const
{
  return static_cast<mfast::int32_cref>((*this)[1]);
}

inline mfast::int32_cref
SeqTemplate1_cref::seq1_element_cref::try_get_field2() const
{
  return static_cast<mfast::int32_cref>((*this)[1]);
}

inline mfast::int32_mref
SeqTemplate1_mref::seq1_element_mref::set_field2() const
{
  return static_cast<mfast::int32_mref>((*this)[1]);
}

inline
SeqTemplate2_cref::SeqTemplate2_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
SeqTemplate2_cref::SeqTemplate2_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, SeqTemplate2_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
SeqTemplate2_cref::SeqTemplate2_cref(
  const mfast::message_cref& other)
  : base_type(other)
{
}

inline
SeqTemplate2_cref::SeqTemplate2_cref(
  const mfast::field_cref& other)
  : base_type(mfast::field_cref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
SeqTemplate2_cref::operator mfast::message_cref()
{
  return mfast::message_cref(this->storage(), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void SeqTemplate2_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, none_operator_tag, properties_type< 0> >, ext_cref< typename seq2_cref::reference, none_operator_tag, properties_type< 0>  > > ((*this)[0]) );
}

inline
SeqTemplate2_mref::SeqTemplate2_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
SeqTemplate2_mref::SeqTemplate2_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, SeqTemplate2_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
SeqTemplate2_mref::SeqTemplate2_mref(
  const mfast::message_mref& other)
  : base_type(other)
{
}

inline
SeqTemplate2_mref::SeqTemplate2_mref(
  const mfast::field_mref_base& other)
  : base_type(other.allocator(),
              mfast::field_mref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
SeqTemplate2_mref::operator mfast::message_mref()
{
  return mfast::message_mref(this->allocator(), const_cast<mfast::value_storage*>(this->storage()), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void SeqTemplate2_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, none_operator_tag, properties_type< 0> >, ext_mref< typename seq2_mref::reference, none_operator_tag, properties_type< 0>  > > ((*this)[0]) );
}

inline
SeqTemplate2::SeqTemplate2(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
SeqTemplate2::SeqTemplate2(
  const SeqTemplate2_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

#ifdef MFAST_JSON_H
SeqTemplate2::SeqTemplate2(
  const char* json_initializer,
  int json_object_tag_mask,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
  std::stringstream strm(json_initializer);
  mfast::json::decode(strm, this->mref(), json_object_tag_mask);
}

#endif
inline SeqTemplate2::cref_type
SeqTemplate2::ref() const
{
  return SeqTemplate2::cref_type(my_storage_.of_group.content_, instruction());
}

inline SeqTemplate2::cref_type
SeqTemplate2::cref() const
{
  return SeqTemplate2::cref_type(my_storage_.of_group.content_, instruction());
}

inline SeqTemplate2::mref_type
SeqTemplate2::ref()
{
  return SeqTemplate2::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline SeqTemplate2::mref_type
SeqTemplate2::mref()
{
  return SeqTemplate2::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline SeqTemplate2_cref::seq2_cref
SeqTemplate2_cref::get_seq2() const
{
  return static_cast<SeqTemplate2_cref::seq2_cref>((*this)[0]);
}

inline SeqTemplate2_cref::seq2_cref
SeqTemplate2_cref::try_get_seq2() const
{
  return static_cast<SeqTemplate2_cref::seq2_cref>((*this)[0]);
}

inline SeqTemplate2_mref::seq2_mref
SeqTemplate2_mref::set_seq2() const
{
  return static_cast<SeqTemplate2_mref::seq2_mref>((*this)[0]);
}

inline
UsingSeqTemplates_cref::UsingSeqTemplates_cref()
  : base_type(nullptr, nullptr)
{
}

template <typename T>inline
UsingSeqTemplates_cref::UsingSeqTemplates_cref(
  typename std::enable_if<std::is_same<typename T::cref_type, UsingSeqTemplates_cref>::value, const mfast::value_storage*>::type storage_array,
  const T* instruction)
  : base_type(storage_array, instruction)
{
}

inline
UsingSeqTemplates_cref::UsingSeqTemplates_cref(
  const mfast::message_cref& other)
  : base_type(other)
{
}

inline
UsingSeqTemplates_cref::UsingSeqTemplates_cref(
  const mfast::field_cref& other)
  : base_type(mfast::field_cref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
UsingSeqTemplates_cref::operator mfast::message_cref()
{
  return mfast::message_cref(this->storage(), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void UsingSeqTemplates_cref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_cref<ascii_string_cref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, none_operator_tag, properties_type< 0> >, ext_cref< typename seq1_cref::reference, sequence_element_tag,properties_type< 0> > > ((*this)[1]) );
  visitor.visit(ext_cref< sequence_cref, ext_cref<uint32_cref, none_operator_tag, properties_type< 0> >, ext_cref< typename seq2_cref::reference, none_operator_tag, properties_type< 0>  > > ((*this)[2]) );
}

inline
UsingSeqTemplates_mref::UsingSeqTemplates_mref()
  : base_type(nullptr, nullptr, nullptr)
{
}

template <typename T>inline
UsingSeqTemplates_mref::UsingSeqTemplates_mref(
  mfast::allocator* alloc,
  typename std::enable_if<std::is_same<typename T::cref_type, UsingSeqTemplates_cref>::value, mfast::value_storage*>::type storage_array,
  const T*          instruction)
  : base_type(alloc, storage_array, instruction)
{
}

inline
UsingSeqTemplates_mref::UsingSeqTemplates_mref(
  const mfast::message_mref& other)
  : base_type(other)
{
}

inline
UsingSeqTemplates_mref::UsingSeqTemplates_mref(
  const mfast::field_mref_base& other)
  : base_type(other.allocator(),
              mfast::field_mref_core_access::storage_of(other)->of_group.content_,
              static_cast<instruction_cptr>(other.instruction()))
{
}

inline
UsingSeqTemplates_mref::operator mfast::message_mref()
{
  return mfast::message_mref(this->allocator(), const_cast<mfast::value_storage*>(this->storage()), static_cast<instruction_cptr>(this->instruction()));
}

template <typename Visitor>
inline void UsingSeqTemplates_mref::accept(Visitor& visitor)
{
  using namespace mfast;
  visitor.visit(ext_mref<ascii_string_mref, none_operator_tag, properties_type< 0> > ((*this)[0]) );
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, none_operator_tag, properties_type< 0> >, ext_mref< typename seq1_mref::reference, sequence_element_tag,properties_type< 0> > > ((*this)[1]) );
  visitor.visit(ext_mref< sequence_mref, ext_mref<uint32_mref, none_operator_tag, properties_type< 0> >, ext_mref< typename seq2_mref::reference, none_operator_tag, properties_type< 0>  > > ((*this)[2]) );
}

inline
UsingSeqTemplates::UsingSeqTemplates(
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
}

inline
UsingSeqTemplates::UsingSeqTemplates(
  const UsingSeqTemplates_cref& other,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data(), other.field_storage(0))
{
}

#ifdef MFAST_JSON_H
UsingSeqTemplates::UsingSeqTemplates(
  const char* json_initializer,
  int json_object_tag_mask,
  mfast::allocator* alloc)
  : base_type(alloc, instruction(), this->data())
{
  std::stringstream strm(json_initializer);
  mfast::json::decode(strm, this->mref(), json_object_tag_mask);
}

#endif
inline UsingSeqTemplates::cref_type
UsingSeqTemplates::ref() const
{
  return UsingSeqTemplates::cref_type(my_storage_.of_group.content_, instruction());
}

inline UsingSeqTemplates::cref_type
UsingSeqTemplates::cref() const
{
  return UsingSeqTemplates::cref_type(my_storage_.of_group.content_, instruction());
}

inline UsingSeqTemplates::mref_type
UsingSeqTemplates::ref()
{
  return UsingSeqTemplates::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline UsingSeqTemplates::mref_type
UsingSeqTemplates::mref()
{
  return UsingSeqTemplates::mref_type(alloc_, my_storage_.of_group.content_, instruction());
}

inline mfast::ascii_string_cref
UsingSeqTemplates_cref::get_string_field() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_cref
UsingSeqTemplates_cref::try_get_string_field() const
{
  return static_cast<mfast::ascii_string_cref>((*this)[0]);
}

inline mfast::ascii_string_mref
UsingSeqTemplates_mref::set_string_field() const
{
  return static_cast<mfast::ascii_string_mref>((*this)[0]);
}

inline UsingSeqTemplates_cref::seq1_cref
UsingSeqTemplates_cref::get_seq1() const
{
  return static_cast<UsingSeqTemplates_cref::seq1_cref>((*this)[1]);
}

inline UsingSeqTemplates_cref::seq1_cref
UsingSeqTemplates_cref::try_get_seq1() const
{
  return static_cast<UsingSeqTemplates_cref::seq1_cref>((*this)[1]);
}

inline UsingSeqTemplates_mref::seq1_mref
UsingSeqTemplates_mref::set_seq1() const
{
  return static_cast<UsingSeqTemplates_mref::seq1_mref>((*this)[1]);
}

inline UsingSeqTemplates_cref::seq2_cref
UsingSeqTemplates_cref::get_seq2() const
{
  return static_cast<UsingSeqTemplates_cref::seq2_cref>((*this)[2]);
}

inline UsingSeqTemplates_cref::seq2_cref
UsingSeqTemplates_cref::try_get_seq2() const
{
  return static_cast<UsingSeqTemplates_cref::seq2_cref>((*this)[2]);
}

inline UsingSeqTemplates_mref::seq2_mref
UsingSeqTemplates_mref::set_seq2() const
{
  return static_cast<UsingSeqTemplates_mref::seq2_mref>((*this)[2]);
}

