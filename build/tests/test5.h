// test5.h generated by mFAST from FAST Template. 
// Do not modify this file directly. Any modifications 
// will be lost the next time this file is generated.

#pragma once

#include <mfast.h>
namespace test5
{

class LoginAccount_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<LoginAccount_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    LoginAccount_cref();
    template <typename T>
    LoginAccount_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, LoginAccount_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    LoginAccount_cref(const mfast::message_cref& other);

    explicit LoginAccount_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_userName() const;
    mfast::ascii_string_cref try_get_userName() const;
    mfast::ascii_string_cref get_password() const;
    mfast::ascii_string_cref try_get_password() const;

};


typedef mfast::make_aggregate_mref<LoginAccount_cref> LoginAccount_mref_base;
class LoginAccount_mref
  : public LoginAccount_mref_base
{
  typedef LoginAccount_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<LoginAccount_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    LoginAccount_mref();
    template <typename T>
    LoginAccount_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, LoginAccount_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    LoginAccount_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit LoginAccount_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_mref set_userName() const;
    mfast::ascii_string_mref set_password() const;
};

class LoginAccount
  : private mfast::value_storage_array<2>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 0
    };
    typedef mfast::template_instruction_ex<LoginAccount_cref> instruction_type;

    typedef mfast::make_message_cref<LoginAccount_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<LoginAccount_mref, instruction_type> mref_type;
    LoginAccount(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    LoginAccount(
      const LoginAccount_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit LoginAccount(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    LoginAccount(const LoginAccount&);
    LoginAccount& operator = (const LoginAccount&);
};


class BankAccount_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<BankAccount_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    BankAccount_cref();
    template <typename T>
    BankAccount_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, BankAccount_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    BankAccount_cref(const mfast::message_cref& other);

    explicit BankAccount_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint64_cref get_number() const;
    mfast::uint64_cref try_get_number() const;
    mfast::uint64_cref get_routingNumber() const;
    mfast::uint64_cref try_get_routingNumber() const;
    mfast::ascii_string_cref get_bank() const;
    mfast::ascii_string_cref try_get_bank() const;
    mfast::ascii_string_cref get_alias() const;
    mfast::ascii_string_cref try_get_alias() const;

};


typedef mfast::make_aggregate_mref<BankAccount_cref> BankAccount_mref_base;
class BankAccount_mref
  : public BankAccount_mref_base
{
  typedef BankAccount_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<BankAccount_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    BankAccount_mref();
    template <typename T>
    BankAccount_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, BankAccount_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    BankAccount_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit BankAccount_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint64_mref set_number() const;
    mfast::uint64_mref set_routingNumber() const;
    mfast::ascii_string_mref set_bank() const;
    void omit_bank() const;
    mfast::ascii_string_mref set_alias() const;
    void omit_alias() const;
};

class BankAccount
  : private mfast::value_storage_array<4>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 0
    };
    typedef mfast::template_instruction_ex<BankAccount_cref> instruction_type;

    typedef mfast::make_message_cref<BankAccount_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<BankAccount_mref, instruction_type> mref_type;
    BankAccount(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    BankAccount(
      const BankAccount_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit BankAccount(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    BankAccount(const BankAccount&);
    BankAccount& operator = (const BankAccount&);
};


class Person_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<Person_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Person_cref();
    template <typename T>
    Person_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, Person_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    Person_cref(const mfast::message_cref& other);

    explicit Person_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_firstName() const;
    mfast::ascii_string_cref try_get_firstName() const;
    mfast::ascii_string_cref get_lastName() const;
    mfast::ascii_string_cref try_get_lastName() const;
    mfast::uint32_cref get_age() const;
    mfast::uint32_cref try_get_age() const;

    class address_cref
      : public mfast::aggregate_cref
    {
      typedef mfast::aggregate_cref base_type;
      public:
        typedef mfast::group_instruction_ex<address_cref> instruction_type;

        typedef const instruction_type* instruction_cptr;
        address_cref();
        template <typename T>
        address_cref(
          typename std::enable_if<std::is_same<typename T::cref_type, address_cref>::value, const mfast::value_storage*>::type storage,
          const T* instruction);

        explicit address_cref(const mfast::field_cref& other);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::ascii_string_cref get_streetAddress() const;
        mfast::ascii_string_cref try_get_streetAddress() const;
        mfast::ascii_string_cref get_city() const;
        mfast::ascii_string_cref try_get_city() const;
        mfast::ascii_string_cref get_state() const;
        mfast::ascii_string_cref try_get_state() const;
        mfast::uint32_cref get_postalCode() const;
        mfast::uint32_cref try_get_postalCode() const;
    };

    address_cref get_address() const;
    address_cref try_get_address() const;

    class phoneNumbers_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<phoneNumbers_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        phoneNumbers_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::ascii_string_cref get_type() const;
        mfast::ascii_string_cref try_get_type() const;
        mfast::ascii_string_cref get_number() const;
        mfast::ascii_string_cref try_get_number() const;
    };

    typedef mfast::make_sequence_cref<phoneNumbers_element_cref> phoneNumbers_cref;
    phoneNumbers_cref get_phoneNumbers() const;
    phoneNumbers_cref try_get_phoneNumbers() const;
    typedef mfast::make_sequence_cref<mfast::ascii_string_cref, mfast::sole_element_sequence_trait> emails_cref;
    emails_cref get_emails() const;
    emails_cref try_get_emails() const;
    typedef LoginAccount_cref login_cref;
    login_cref get_login() const;
    login_cref try_get_login() const;
    typedef mfast::make_sequence_cref<BankAccount_cref, mfast::defined_element_sequence_trait> bankAccounts_cref;
    bankAccounts_cref get_bankAccounts() const;
    bankAccounts_cref try_get_bankAccounts() const;

};


typedef mfast::make_aggregate_mref<Person_cref> Person_mref_base;
class Person_mref
  : public Person_mref_base
{
  typedef Person_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<Person_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Person_mref();
    template <typename T>
    Person_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, Person_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    Person_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit Person_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_mref set_firstName() const;
    mfast::ascii_string_mref set_lastName() const;
    mfast::uint32_mref set_age() const;

    class address_mref
      : public mfast::make_aggregate_mref<Person_cref::address_cref>
    {
      typedef mfast::make_aggregate_mref<Person_cref::address_cref> base_type;
      public:
        address_mref();
        template <typename T>
        address_mref(
          mfast::allocator*       alloc,
          typename std::enable_if<std::is_same<typename T::cref_type, address_cref>::value, mfast::value_storage*>::type   storage,
          const T* instruction);

        explicit address_mref(const mfast::field_mref_base& other);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::ascii_string_mref set_streetAddress() const;
        mfast::ascii_string_mref set_city() const;
        mfast::ascii_string_mref set_state() const;
        mfast::uint32_mref set_postalCode() const;
    };

    address_mref set_address() const;
    void omit_address() const;

    class phoneNumbers_element_mref
      : public mfast::make_aggregate_mref<Person_cref::phoneNumbers_element_cref>
    {
      typedef mfast::make_aggregate_mref<Person_cref::phoneNumbers_element_cref> base_type;
      public:
        phoneNumbers_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::ascii_string_mref set_type() const;
        mfast::ascii_string_mref set_number() const;
    };

    typedef mfast::make_sequence_mref<phoneNumbers_element_mref> phoneNumbers_mref;
    phoneNumbers_mref set_phoneNumbers() const;
    typedef mfast::make_sequence_mref<mfast::ascii_string_mref, mfast::sole_element_sequence_trait> emails_mref;
    emails_mref set_emails() const;
    typedef LoginAccount_mref login_mref;
    login_mref set_login() const;
    void omit_login() const;
    void link_login(const login_mref& ref) const;
    void unlink_login() const;
    typedef mfast::make_sequence_mref<BankAccount_mref, mfast::defined_element_sequence_trait> bankAccounts_mref;
    bankAccounts_mref set_bankAccounts() const;
    void omit_bankAccounts() const;
};

class Person
  : private mfast::value_storage_array<8>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 0
    };
    typedef mfast::template_instruction_ex<Person_cref> instruction_type;

    typedef mfast::make_message_cref<Person_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<Person_mref, instruction_type> mref_type;
    Person(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    Person(
      const Person_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit Person(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    Person(const Person&);
    Person& operator = (const Person&);
};


  class PersonView
  {
  public:
    typedef mfast::view_iterator iterator;
    typedef mfast::view_iterator const_iterator;
    PersonView(const Person_cref& ref);

    iterator begin() const;
    iterator end() const;
    template <typename FieldAccessor>
    void accept_accessor(FieldAccessor& accessor) const;

  private:
    Person_cref ref_;
    static const mfast::aggregate_view_info info_;
  };

struct  templates_description
  : mfast::templates_description
{
  typedef std::tuple<> types;
  templates_description();
  static const templates_description* instance();
};

inline const templates_description* description()
{
  return templates_description::instance();
}

#include "test5.inl"
}
