// example.h generated by mFAST from FAST Template. 
// Do not modify this file directly. Any modifications 
// will be lost the next time this file is generated.

#pragma once

#include <mfast.h>
namespace example
{

class Done_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<Done_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Done_cref();
    template <typename T>
    Done_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, Done_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    Done_cref(const mfast::message_cref& other);

    explicit Done_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_MessageType() const;
    mfast::ascii_string_cref try_get_MessageType() const;

};


typedef mfast::make_aggregate_mref<Done_cref> Done_mref_base;
class Done_mref
  : public Done_mref_base
{
  typedef Done_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<Done_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    Done_mref();
    template <typename T>
    Done_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, Done_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    Done_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit Done_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

};

class Done
  : private mfast::value_storage_array<1>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 99
    };
    typedef mfast::template_instruction_ex<Done_cref> instruction_type;

    typedef mfast::make_message_cref<Done_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<Done_mref, instruction_type> mref_type;
    Done(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    Done(
      const Done_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit Done(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    Done(const Done&);
    Done& operator = (const Done&);
};


class MarketData_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<MarketData_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    MarketData_cref();
    template <typename T>
    MarketData_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, MarketData_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    MarketData_cref(const mfast::message_cref& other);

    explicit MarketData_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_ApplVerID() const;
    mfast::ascii_string_cref try_get_ApplVerID() const;
    mfast::ascii_string_cref get_MessageType() const;
    mfast::ascii_string_cref try_get_MessageType() const;
    mfast::ascii_string_cref get_SenderCompID() const;
    mfast::ascii_string_cref try_get_SenderCompID() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint32_cref get_SendingTime() const;
    mfast::uint32_cref try_get_SendingTime() const;
    mfast::uint32_cref get_TradeDate() const;
    mfast::uint32_cref try_get_TradeDate() const;

    class MDEntries_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<MDEntries_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        MDEntries_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_cref get_MDUpdateAction() const;
        mfast::uint32_cref try_get_MDUpdateAction() const;
        mfast::uint32_cref get_MDPriceLevel() const;
        mfast::uint32_cref try_get_MDPriceLevel() const;
        mfast::ascii_string_cref get_MDEntryType() const;
        mfast::ascii_string_cref try_get_MDEntryType() const;
        mfast::uint32_cref get_OpenCloseSettleFlag() const;
        mfast::uint32_cref try_get_OpenCloseSettleFlag() const;
        mfast::uint32_cref get_SecurityIDSource() const;
        mfast::uint32_cref try_get_SecurityIDSource() const;
        mfast::uint32_cref get_SecurityID() const;
        mfast::uint32_cref try_get_SecurityID() const;
        mfast::uint32_cref get_RptSeq() const;
        mfast::uint32_cref try_get_RptSeq() const;
        mfast::decimal_cref get_MDEntryPx() const;
        mfast::decimal_cref try_get_MDEntryPx() const;
        mfast::uint32_cref get_MDEntryTime() const;
        mfast::uint32_cref try_get_MDEntryTime() const;
        mfast::int32_cref get_MDEntrySize() const;
        mfast::int32_cref try_get_MDEntrySize() const;
        mfast::uint32_cref get_NumberOfOrders() const;
        mfast::uint32_cref try_get_NumberOfOrders() const;
        mfast::ascii_string_cref get_TradingSessionID() const;
        mfast::ascii_string_cref try_get_TradingSessionID() const;
        mfast::decimal_cref get_NetChgPrevDay() const;
        mfast::decimal_cref try_get_NetChgPrevDay() const;
        mfast::uint32_cref get_TradeVolume() const;
        mfast::uint32_cref try_get_TradeVolume() const;
        mfast::ascii_string_cref get_TradeCondition() const;
        mfast::ascii_string_cref try_get_TradeCondition() const;
        mfast::ascii_string_cref get_TickDirection() const;
        mfast::ascii_string_cref try_get_TickDirection() const;
        mfast::ascii_string_cref get_QuoteCondition() const;
        mfast::ascii_string_cref try_get_QuoteCondition() const;
        mfast::uint32_cref get_AggressorSide() const;
        mfast::uint32_cref try_get_AggressorSide() const;
        mfast::ascii_string_cref get_MatchEventIndicator() const;
        mfast::ascii_string_cref try_get_MatchEventIndicator() const;
    };

    typedef mfast::make_sequence_cref<MDEntries_element_cref> MDEntries_cref;
    MDEntries_cref get_MDEntries() const;
    MDEntries_cref try_get_MDEntries() const;

};


typedef mfast::make_aggregate_mref<MarketData_cref> MarketData_mref_base;
class MarketData_mref
  : public MarketData_mref_base
{
  typedef MarketData_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<MarketData_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    MarketData_mref();
    template <typename T>
    MarketData_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, MarketData_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    MarketData_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit MarketData_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    mfast::uint32_mref set_SendingTime() const;
    mfast::uint32_mref set_TradeDate() const;

    class MDEntries_element_mref
      : public mfast::make_aggregate_mref<MarketData_cref::MDEntries_element_cref>
    {
      typedef mfast::make_aggregate_mref<MarketData_cref::MDEntries_element_cref> base_type;
      public:
        MDEntries_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint32_mref set_MDUpdateAction() const;
        mfast::uint32_mref set_MDPriceLevel() const;
        void omit_MDPriceLevel() const;
        mfast::ascii_string_mref set_MDEntryType() const;
        mfast::uint32_mref set_OpenCloseSettleFlag() const;
        void omit_OpenCloseSettleFlag() const;
        mfast::uint32_mref set_SecurityID() const;
        mfast::uint32_mref set_RptSeq() const;
        mfast::decimal_mref set_MDEntryPx() const;
        mfast::uint32_mref set_MDEntryTime() const;
        mfast::int32_mref set_MDEntrySize() const;
        void omit_MDEntrySize() const;
        mfast::uint32_mref set_NumberOfOrders() const;
        void omit_NumberOfOrders() const;
        mfast::ascii_string_mref set_TradingSessionID() const;
        void omit_TradingSessionID() const;
        mfast::decimal_mref set_NetChgPrevDay() const;
        void omit_NetChgPrevDay() const;
        mfast::uint32_mref set_TradeVolume() const;
        void omit_TradeVolume() const;
        mfast::ascii_string_mref set_TradeCondition() const;
        void omit_TradeCondition() const;
        mfast::ascii_string_mref set_TickDirection() const;
        void omit_TickDirection() const;
        mfast::ascii_string_mref set_QuoteCondition() const;
        void omit_QuoteCondition() const;
        mfast::uint32_mref set_AggressorSide() const;
        void omit_AggressorSide() const;
        mfast::ascii_string_mref set_MatchEventIndicator() const;
        void omit_MatchEventIndicator() const;
    };

    typedef mfast::make_sequence_mref<MDEntries_element_mref> MDEntries_mref;
    MDEntries_mref set_MDEntries() const;
};

class MarketData
  : private mfast::value_storage_array<7>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 1
    };
    typedef mfast::template_instruction_ex<MarketData_cref> instruction_type;

    typedef mfast::make_message_cref<MarketData_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<MarketData_mref, instruction_type> mref_type;
    MarketData(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    MarketData(
      const MarketData_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit MarketData(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    MarketData(const MarketData&);
    MarketData& operator = (const MarketData&);
};


class QuoteRequest_cref
  : public mfast::aggregate_cref
{
  typedef mfast::aggregate_cref base_type;
  public:
    typedef mfast::template_instruction_ex<QuoteRequest_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    QuoteRequest_cref();
    template <typename T>
    QuoteRequest_cref(
      typename std::enable_if<std::is_same<typename T::cref_type, QuoteRequest_cref>::value, const mfast::value_storage*>::type storage,
      const T* instruction);

    QuoteRequest_cref(const mfast::message_cref& other);

    explicit QuoteRequest_cref(const mfast::field_cref& other);

    operator mfast::message_cref();
    template <typename Visitor>
    void accept(Visitor& v);

    mfast::ascii_string_cref get_ApplVerID() const;
    mfast::ascii_string_cref try_get_ApplVerID() const;
    mfast::ascii_string_cref get_MessageType() const;
    mfast::ascii_string_cref try_get_MessageType() const;
    mfast::ascii_string_cref get_SenderCompID() const;
    mfast::ascii_string_cref try_get_SenderCompID() const;
    mfast::uint32_cref get_MsgSeqNum() const;
    mfast::uint32_cref try_get_MsgSeqNum() const;
    mfast::uint32_cref get_SendingTime() const;
    mfast::uint32_cref try_get_SendingTime() const;
    mfast::ascii_string_cref get_QuoteReqID() const;
    mfast::ascii_string_cref try_get_QuoteReqID() const;

    class RelatedSym_element_cref
      : public mfast::sequence_element_cref
    {
      typedef mfast::sequence_element_cref base_type;
      public:
        typedef mfast::sequence_instruction_ex<RelatedSym_element_cref> instruction_type;
        typedef const instruction_type* instruction_cptr;
        RelatedSym_element_cref(
          const mfast::value_storage* storage,
          instruction_cptr            instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::ascii_string_cref get_Symbol() const;
        mfast::ascii_string_cref try_get_Symbol() const;
        mfast::uint64_cref get_OrderQty() const;
        mfast::uint64_cref try_get_OrderQty() const;
        mfast::uint32_cref get_Side() const;
        mfast::uint32_cref try_get_Side() const;
        mfast::uint64_cref get_TransactTime() const;
        mfast::uint64_cref try_get_TransactTime() const;
        mfast::uint32_cref get_QuoteType() const;
        mfast::uint32_cref try_get_QuoteType() const;
        mfast::uint32_cref get_SecurityID() const;
        mfast::uint32_cref try_get_SecurityID() const;
        mfast::uint32_cref get_SecurityIDSource() const;
        mfast::uint32_cref try_get_SecurityIDSource() const;
    };

    typedef mfast::make_sequence_cref<RelatedSym_element_cref> RelatedSym_cref;
    RelatedSym_cref get_RelatedSym() const;
    RelatedSym_cref try_get_RelatedSym() const;

};


typedef mfast::make_aggregate_mref<QuoteRequest_cref> QuoteRequest_mref_base;
class QuoteRequest_mref
  : public QuoteRequest_mref_base
{
  typedef QuoteRequest_mref_base base_type;
  public:
    typedef mfast::template_instruction_ex<QuoteRequest_cref> instruction_type;
    typedef const instruction_type* instruction_cptr;
    QuoteRequest_mref();
    template <typename T>
    QuoteRequest_mref(
      mfast::allocator*       alloc,
      typename std::enable_if<std::is_same<typename T::cref_type, QuoteRequest_cref>::value, mfast::value_storage*>::type   storage,
      const T* instruction);

    QuoteRequest_mref(const mfast::message_mref& other);

    operator mfast::message_mref();
    explicit QuoteRequest_mref(const mfast::field_mref_base& other);

    template <typename Visitor>
    void accept(Visitor& v);

    mfast::uint32_mref set_MsgSeqNum() const;
    mfast::uint32_mref set_SendingTime() const;
    mfast::ascii_string_mref set_QuoteReqID() const;
    void omit_QuoteReqID() const;

    class RelatedSym_element_mref
      : public mfast::make_aggregate_mref<QuoteRequest_cref::RelatedSym_element_cref>
    {
      typedef mfast::make_aggregate_mref<QuoteRequest_cref::RelatedSym_element_cref> base_type;
      public:
        RelatedSym_element_mref(
          mfast::allocator*     alloc,
          mfast::value_storage* storage,
          instruction_cptr      instruction);

        template <typename Visitor>
        void accept(Visitor& v);

        mfast::uint64_mref set_OrderQty() const;
        void omit_OrderQty() const;
        mfast::uint32_mref set_Side() const;
        void omit_Side() const;
        mfast::uint64_mref set_TransactTime() const;
        mfast::uint32_mref set_QuoteType() const;
        mfast::uint32_mref set_SecurityID() const;
    };

    typedef mfast::make_sequence_mref<RelatedSym_element_mref> RelatedSym_mref;
    RelatedSym_mref set_RelatedSym() const;
};

class QuoteRequest
  : private mfast::value_storage_array<7>
  , public mfast::message_type
{
  typedef mfast::message_type base_type;
  public:
    enum {
      the_id = 2
    };
    typedef mfast::template_instruction_ex<QuoteRequest_cref> instruction_type;

    typedef mfast::make_message_cref<QuoteRequest_cref, instruction_type> cref_type;
    typedef mfast::make_message_mref<QuoteRequest_mref, instruction_type> mref_type;
    QuoteRequest(
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
    QuoteRequest(
      const QuoteRequest_cref& other,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#ifdef MFAST_JSON_H
    explicit QuoteRequest(
      const char* json_initializer,
      int json_object_tag_mask=0,
      mfast::allocator* alloc=mfast::malloc_allocator::instance());
#endif // MFAST_JSON_H
    cref_type ref() const;
    cref_type cref() const;
    mref_type ref();
    mref_type mref();
    static const instruction_type* instruction();
  private:
    QuoteRequest(const QuoteRequest&);
    QuoteRequest& operator = (const QuoteRequest&);
};


struct  templates_description
  : mfast::templates_description
{
  typedef std::tuple<Done,
                       MarketData,
                       QuoteRequest> types;
  templates_description();
  static const templates_description* instance();
};

inline const templates_description* description()
{
  return templates_description::instance();
}

#include "example.inl"
}
