# mFast-Protocol
mFast protocol, cpp file generator
If you want to build binary then go to build folder and build binary using .sln file





# Generating C++ classes from FAST XML specification files
mFAST provides two approaches to incorporate FAST template specification into applications. The first (and preferred) approach is using the tool fast_type_gen to generate C++ types for corresponding FAST templates. Using the generated C++ types makes it easier to read/write application code and provides stronger type safety. It also eliminates the need to parse the XML specification at runtime and thus reduce application memory footprint. The fast_type_gen tool is located under the $MFAST_BUILD_DIR/bin directory. At current stage, it only takes FAST XML files as its arguments and generating C++ files without any options like the following.

$MFAST_BUILD_DIR/bin/fast_type_gen test1.xml test2.xml
For each XML specification file, fast_type_gen will generate three files (.h, .inl and .cpp) with the base name of those generated files and the same with their corresponding xml file. The C++ namespace of the generated C++ classes are also the same with the base filename. Currently, There is no other way to change the namespace unless you change the filename of the input XML file or directly modify the generated code.

If your input XML specification files have dependencies among them, all input files must be generated at once; i.e. you cannot do something like fast_type_gen input1.xml and then fast_type_gen input2.xml if input2.xml is dependent on input1.xml. An input FAST specification file A is only dependent on another file B if and only if B contains a static templateRef where the name of templateRef is only defined in A. In addition, fast_type_gen cannot handle circular dependency between its input files.

To encode/decode FAST messages correctly, each FAST template must have a unique template identifier. The specification does not define how to map template names to template identifiers. In our implementation, we choose to use the number specified by the id attribute in the template definition, as the template identifier for encoder/decoder purposes. Furthermore, even though FAST specification does not have any restriction on what the id attributes for fields can be, fast_type_gen can generate valid C++ code only when the value for id attributes are unsigned 32 bits integers.

There are some limitations in the current implementation of mFAST. For one, fast_type_gen is not robust enough to report syntactic or semantic errors from its input files. It's possible that the code generation process can succeed and yet the generated code won't compile or even executed correctly if errors exist in its input files. For example, if the names of templates or fields are not valid C++ identifiers, the generated code would not compile. This is an issue to be addressed in the future release of this product.

Another approach to use a template specification is to explicitly read the XML file in the application; however, this approach loses type safety and the XML parser would increase the application memory footprint. We will further discuss the API for this approach later.







# FAST Template to mFAST C++ Type Mapping
In order to maximize the space efficiency of deserialized FAST messages while providing a user friendly API, mFAST employs a very unique mapping of FAST templates to C++ types. Unlike OMG IDL/C++ type mapping or Google Protocol Buffers, where each message type is represented by a C++ struct/class and the struct/class is responsible for resource management as well as providing getter/setter functions for accessing field values; mFAST separates those roles into different C++ classes. For the previous mentioned example FAST template MDRefreshSample, three C++ classes named MDRefreshSample, MDRefreshSample_cref and MDRefreshSample_mref are generated by fast_type_gen. Based on their functionalities, we name them as value holder, constant reference and mutable reference classes respectively.

A value holder class manages the internal resources needed by fields of a message, it does not provide getters/setters to read or write its contained fields. The member functions it provides only allows you to construct/copy the value or to create the reference objects. Suppose the previous mentioned FAST templates XML is saved as 'example.xml', the generated MDRefreshSample would be as follows.

# ðŸ§¾ Example: Generated C++ Header from `example.xml`

The following C++ code is generated by `fast_type_gen` from `example.xml`:

```cpp
// example.h, generated from fast_type_gen example.xml
namespace example {

class MDRefreshSample_cref : public mfast::message_cref {
  // ...
};

class MDRefreshSample_mref : public MDRefreshSample_cref {
  // ...
};

class MDRefreshSample
  : private boost::array<mfast::value_storage, 6>,
    public mfast::message_type
{
public:
  enum {
    the_id = 10001
  };

  MDRefreshSample(
    mfast::allocator* alloc = mfast::malloc_allocator::instance());

  MDRefreshSample(
    const MDRefreshSample_cref& other,
    mfast::allocator* alloc = mfast::malloc_allocator::instance());

  MDRefreshSample_cref ref() const;
  MDRefreshSample_cref cref() const;
  MDRefreshSample_mref ref();
  MDRefreshSample_mref mref();

private:
  MDRefreshSample(const MDRefreshSample&);
  MDRefreshSample& operator=(const MDRefreshSample&);
};

mfast::templates_description* description();

} // namespace example
```

Constant and mutable reference objects, on the other hand, are used for reading/writing field values, testing the presence of a field, and querying field meta data. Each type in FAST specification, whether primitive or not, has its own representative constant/mutable reference classes. The following figure is the UML representation for the basic constant reference classes.

![image](https://github.com/user-attachments/assets/0827010a-ec9a-4e6a-a225-bbb3beeb3379)


Figure 1. mFAST constant reference class hierarchy

At the center of figure is the field_cref class, which is the base for all those constant reference classes can be directly used to refer fields. It provides present() for testing the presence of the value and other functions to query meta data such as name(), id(), or field_type().

The classes to the left of field_cref represent the references for the FAST primitive types. All references classes for numeric types provides a value() member function. The references classes for string and vector types provides interfaces like the const member function of std::string and std::vector<T> respectively.

group_cref and sequence_cref, representing group and sequence types in FAST, provides access to the nested fields or elements respectively. The sequenece_element_cref class is used to represent the elements in a sequence. It does not inherit from field_cref because it does not correspond to a field in FAST sense. The class nested_message_cref, on the other hand, represents templateRef in FAST. The class message_cref, corresponding to template in FAST, is the base class for topmost level application types. The class aggregate_cref provides an abstraction to represent a collection of fields regardless whether the containing type is a group, a message or a element in a sequence.

In the MDRefreshSample example, to read the contained fields, we need to use cref() to obtain anMDRefreshSample_cref object. The generated MDRefreshSample_cref class has a set of get_xxx() member functions, where xxx is the field names, used for reading a field value. Likewise, a set of set_xxx() member functions is generated for writing field values in MDRefreshSample_mref. All getter/setter member functions return constant and mutable reference objects of their corresponding field types. This is very different from Google protocol buffer where simple value are returned from getters or passed as parameter to setters.

Here is an example for reading field values in mFAST.

```cpp
using namespace mfast;
void print_sample(const example::MDRefreshSample_cref& ref)
{
  cout << ref.get_BeginString().name() << " : " << ref.get_BeginString().c_str() << "\n";
  if (ref.get_ApplVerID().present())
     cout << ref.get_ApplVerID().name() << " : " << ref.get_ApplVerID().c_str() << "\n";
  cout << ref.get_MsgSeqNum().name() << " : " << ref.get_MsgSeqNum().value() << "\n";

  for (auto entry : ref.get_MDEntries()) {
     cout << entry.get_MDUpdateAction().name() << " : " << entry.get_MDUpdateAction().c_str();
   // ...
  }
}

example::MDRefreshSample message;

// message value is assigned somewhere else

print_sample(message.cref());
```

All mutable reference classes are derived from the const reference counterpart. In other words, int32_cref is the base class of int32_mref, seqence_cref is the base class of sequence_mref, etc. However, field_mref is not the base class of more specific mutable reference classes for fields such as int32_mref or sequence_mref; instead, those classes have an explicit type conversion constructor so that it's possible to static_cast from a field_mref object to a more specific mutable reference object. The following code demonstrates how to assign fields values.

```cpp
using namespace mfast;
example::MDRefreshSample message;
example::MDRefreshSample_mref ref = message.mref();
mref.set_ApplVerID().as("A");
assert(mref.get_ApplVerID().present());

mref.set_SenderCompID.as("B");
mref.set_MsgSeqNum().as(1);
auto entries = mref.set_MDEntries();
entries.resize(4);
entries[0].set_MDUpdateAction(1);
// ...

// using omit_xxx() to make optional field absent after assigning value
mref.omit_ApplVerID();
assert(!mref.get_ApplVerID().present());
assert(mref.get_ApplVerID().size() == 0);

// clear() can also make optional field absent
mref.set_ApplVerID("A");
assert(mref.get_ApplVerID().present());
mref.set_ApplVerID().clear();
assert(!mref.get_ApplVerID().present());
assert(mref.get_ApplVerID().size() == 0);


// However, clear() make the size to 0 for
// mandatory vectors, strings and sequences.

assert(mref.set_SenderCompID.present());
assert(mref.set_SenderCompID.size() == 1);

mref.set_SenderCompID.clear(); // becomes zero length string
assert(mref.set_SenderCompID.present());
assert(mref.set_SenderCompID.size() == 0);
```

Notice that mFAST reference objects are like C/C++ build-in pointers in that no logic is involved to track the lifetime of the field/value they refer to; i.e. no reference counting is employed. Once a top level value holder object is destroyed, all the references stem from that value holder object become dangling references. Therefore, it is very important that a reference object cannot be used when its value holder object is destroyed. However, it is possible to create a new value holder object from an existing constant reference object, i.e. object cloning, so that the new value holder has a different lifetime than the object from which it was cloned.

Reference objects are small and inexpensive to copy: a constant reference object contains only 2 pointers internally while a mutable reference object contains 3 pointers. Because no reference counting is involved, copying a reference object does not impede efficiency by damaging cache performance and creating pipeline bubbles.

